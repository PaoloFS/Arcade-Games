<!DOCTYPE html>
<html lang="es">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Arcade Zone - Multiplayer Games</title>
	<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap');

/* ============================================
   MODERN CSS ARCHITECTURE 2025
   - CSS Cascade Layers para organizaci√≥n
   - Container Queries para responsividad
   - Custom Properties con fallbacks
   - Animaciones GPU-optimizadas
   - Logical Properties para i18n
============================================ */

@layer reset, tokens, base, components, utilities, animations;

/* ============================================
   LAYER: RESET
============================================ */
@layer reset {
  *, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  :where(img, picture, video, canvas, svg) {
    display: block;
    max-inline-size: 100%;
  }

  :where(input, button, textarea, select) {
    font: inherit;
  }
}

/* ============================================
   LAYER: DESIGN TOKENS
============================================ */
@layer tokens {
  :root {
    /* Colors - Neon Palette */
    --clr-neon-cyan: oklch(90% 0.25 195);
    --clr-neon-pink: oklch(65% 0.28 350);
    --clr-neon-yellow: oklch(85% 0.22 90);
    --clr-neon-purple: oklch(60% 0.25 285);
    --clr-neon-green: oklch(80% 0.30 145);
    
    /* Backgrounds */
    --clr-bg-dark: oklch(15% 0.05 255);
    --clr-bg-darker: oklch(10% 0.03 255);
    --clr-card-bg: oklch(18% 0.04 255 / 0.95);
    
    /* Fluid Spacing Scale */
    --space-3xs: clamp(0.25rem, 0.23rem + 0.11vw, 0.31rem);
    --space-2xs: clamp(0.5rem, 0.46rem + 0.22vw, 0.63rem);
    --space-xs: clamp(0.75rem, 0.68rem + 0.33vw, 0.94rem);
    --space-sm: clamp(1rem, 0.91rem + 0.43vw, 1.25rem);
    --space-md: clamp(1.5rem, 1.37rem + 0.65vw, 1.88rem);
    --space-lg: clamp(2rem, 1.83rem + 0.87vw, 2.5rem);
    --space-xl: clamp(3rem, 2.74rem + 1.3vw, 3.75rem);
    --space-2xl: clamp(4rem, 3.65rem + 1.74vw, 5rem);
    
    /* Fluid Typography Scale */
    --fs-xs: clamp(0.75rem, 0.71rem + 0.22vw, 0.88rem);
    --fs-sm: clamp(0.88rem, 0.83rem + 0.24vw, 1rem);
    --fs-base: clamp(1rem, 0.96rem + 0.22vw, 1.13rem);
    --fs-md: clamp(1.13rem, 1.08rem + 0.24vw, 1.27rem);
    --fs-lg: clamp(1.27rem, 1.19rem + 0.38vw, 1.5rem);
    --fs-xl: clamp(1.5rem, 1.37rem + 0.65vw, 1.88rem);
    --fs-2xl: clamp(1.88rem, 1.63rem + 1.2vw, 2.5rem);
    --fs-3xl: clamp(2.5rem, 2.07rem + 2.17vw, 3.75rem);
    
    /* Border Radius */
    --radius-sm: 0.5rem;
    --radius-md: 1rem;
    --radius-lg: 1.5rem;
    --radius-full: 9999px;
    
    /* Transitions */
    --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
    --transition-base: 250ms cubic-bezier(0.4, 0, 0.2, 1);
    --transition-slow: 350ms cubic-bezier(0.4, 0, 0.2, 1);
    --transition-bounce: 500ms cubic-bezier(0.34, 1.56, 0.64, 1);
    
    /* Shadows */
    --shadow-glow-cyan: 0 0 20px color-mix(in oklch, var(--clr-neon-cyan), transparent 40%);
    --shadow-glow-pink: 0 0 20px color-mix(in oklch, var(--clr-neon-pink), transparent 40%);
    --shadow-glow-yellow: 0 0 20px color-mix(in oklch, var(--clr-neon-yellow), transparent 40%);
    
    /* Z-index Scale */
    --z-base: 1;
    --z-elevated: 10;
    --z-modal: 100;
    --z-alert: 1000;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      color-scheme: dark;
    }
  }
}

/* ============================================
   LAYER: BASE STYLES
============================================ */
@layer base {
  html {
    color-scheme: dark;
    hanging-punctuation: first last;
  }

  body {
    min-block-size: 100vh;
    min-block-size: 100dvh;
    font-family: 'Orbitron', system-ui, sans-serif;
    color: white;
    background: 
      radial-gradient(ellipse at top, 
        oklch(25% 0.08 255) 0%, 
        oklch(15% 0.05 255) 50%, 
        oklch(5% 0.02 255) 100%);
    background-attachment: fixed;
    overflow-x: clip;
    position: relative;
    
    /* Performance optimizations */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
  }

  /* Animated Background - Optimized */
  .animated-bg {
    position: fixed;
    inset: 0;
    z-index: 0;
    overflow: hidden;
    pointer-events: none;
    contain: layout style paint;
  }

  /* Perspective Grid */
  .grid-lines {
    position: absolute;
    inset: 0;
    background-image: 
      linear-gradient(color-mix(in oklch, var(--clr-neon-cyan), transparent 70%) 1px, transparent 1px),
      linear-gradient(90deg, color-mix(in oklch, var(--clr-neon-cyan), transparent 70%) 1px, transparent 1px);
    background-size: 50px 50px;
    opacity: 0.3;
    transform: perspective(500px) rotateX(60deg);
    will-change: transform;
    animation: gridMove 25s linear infinite;
  }

  /* Floating Particles */
  .animated-bg::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image: 
      radial-gradient(circle, var(--clr-neon-cyan) 1px, transparent 1px),
      radial-gradient(circle, var(--clr-neon-pink) 1px, transparent 1px),
      radial-gradient(circle, var(--clr-neon-purple) 1px, transparent 1px);
    background-size: 300px 300px, 400px 400px, 350px 350px;
    background-position: 0 0, 100px 100px, 200px 50px;
    opacity: 0.15;
    will-change: background-position;
    animation: particleFloat 30s ease-in-out infinite;
  }

  /* Light Rays */
  .animated-bg::after {
    content: '';
    position: absolute;
    inset: -50%;
    background: 
      conic-gradient(from 0deg at 50% 50%, 
        transparent 0deg, 
        color-mix(in oklch, var(--clr-neon-cyan), transparent 95%) 45deg,
        transparent 90deg,
        color-mix(in oklch, var(--clr-neon-pink), transparent 95%) 135deg,
        transparent 180deg);
    will-change: transform;
    animation: lightRotate 40s linear infinite;
  }

  /* Starfield */
  .stars {
    position: absolute;
    inset: 0;
  }

  .star {
    position: absolute;
    inline-size: 2px;
    block-size: 2px;
    background: white;
    border-radius: var(--radius-full);
    box-shadow: 
      0 0 4px color-mix(in oklch, white, transparent 50%),
      0 0 8px color-mix(in oklch, var(--clr-neon-cyan), transparent 70%);
    will-change: opacity, transform;
    animation: twinkle 3s ease-in-out infinite;
  }

  /* Container */
  .container {
    position: relative;
    z-index: var(--z-base);
    max-inline-size: min(1400px, 96vw);
    margin-inline: auto;
    padding-block: var(--space-md);
    padding-inline: var(--space-sm);
  }
}

/* ============================================
   LAYER: COMPONENTS
============================================ */
@layer components {
  
  /* Header */
  .header {
    text-align: center;
    margin-block-end: var(--space-xl);
    padding-block: var(--space-md);
    container-type: inline-size;
  }

  .header h1 {
    font-family: 'Press Start 2P', cursive;
    font-size: var(--fs-2xl);
    line-height: 1.4;
    margin-block-end: var(--space-sm);
    
    background: linear-gradient(
      90deg,
      var(--clr-neon-cyan) 0%,
      var(--clr-neon-pink) 25%,
      var(--clr-neon-yellow) 50%,
      var(--clr-neon-purple) 75%,
      var(--clr-neon-cyan) 100%
    );
    background-size: 200% auto;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    
    filter: drop-shadow(0 0 20px color-mix(in oklch, var(--clr-neon-cyan), transparent 30%));
    will-change: background-position;
    animation: gradientFlow 8s linear infinite;
  }

  .header p {
    font-size: var(--fs-base);
    color: var(--clr-neon-cyan);
    letter-spacing: 0.1em;
    text-shadow: 
      0 0 10px var(--clr-neon-cyan),
      0 0 20px color-mix(in oklch, var(--clr-neon-cyan), transparent 50%);
  }

  /* User Panel */
  .user-panel {
    position: relative;
    background: var(--clr-card-bg);
    border: 2px solid transparent;
    border-radius: var(--radius-lg);
    padding: var(--space-md);
    margin-block-end: var(--space-xl);
    backdrop-filter: blur(12px);
    
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    gap: var(--space-md);
    
    container-type: inline-size;
    contain: layout style paint;
    isolation: isolate;
  }

  .user-panel::before {
    content: '';
    position: absolute;
    inset: 0px;
    border-radius: inherit;
    background: linear-gradient(
      90deg,
      var(--clr-neon-cyan),
      var(--clr-neon-pink),
      var(--clr-neon-yellow),
      var(--clr-neon-cyan)
    );
    background-size: 200% 100%;
    z-index: -1;
    will-change: background-position;
    animation: borderFlow 6s linear infinite;
    mask: 
      linear-gradient(#fff 0 0) content-box, 
      linear-gradient(#fff 0 0);
    mask-composite: exclude;
    -webkit-mask: 
      linear-gradient(#fff 0 0) content-box, 
      linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    padding: 2px;
  }

  .user-info {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
  }

  .user-avatar {
    inline-size: clamp(50px, 10cqi, 70px);
    block-size: clamp(50px, 10cqi, 70px);
    background: linear-gradient(135deg, var(--clr-neon-pink), var(--clr-neon-purple));
    border-radius: var(--radius-full);
    border: 3px solid var(--clr-neon-cyan);
    
    display: grid;
    place-items: center;
    font-size: clamp(1.5rem, 5cqi, 2.5rem);
    
    box-shadow: 
      0 0 20px color-mix(in oklch, var(--clr-neon-pink), transparent 40%),
      inset 0 0 20px color-mix(in oklch, white, transparent 70%);
    
    flex-shrink: 0;
    contain: layout style paint;
  }

  .user-name {
    font-size: var(--fs-md);
    font-weight: 700;
    color: var(--clr-neon-yellow);
    text-shadow: 
      0 0 10px var(--clr-neon-yellow),
      0 0 20px color-mix(in oklch, var(--clr-neon-yellow), transparent 50%);
    word-break: break-word;
    max-inline-size: 30ch;
  }

  /* Input Group */
  .input-group {
    display: flex;
    gap: var(--space-sm);
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
  }

  .arcade-input {
    padding-block: 0.75rem;
    padding-inline: 1rem;
    background: oklch(10% 0.03 255 / 0.6);
    border: 2px solid var(--clr-neon-cyan);
    border-radius: var(--radius-sm);
    color: white;
    font-family: inherit;
    font-size: var(--fs-sm);
    min-inline-size: min(180px, 100%);
    
    transition: all var(--transition-base);
    box-shadow: 
      inset 0 0 15px color-mix(in oklch, var(--clr-neon-cyan), transparent 70%),
      0 0 10px color-mix(in oklch, var(--clr-neon-cyan), transparent 80%);
  }

  .arcade-input:focus {
    outline: none;
    border-color: var(--clr-neon-pink);
    background: oklch(10% 0.03 255 / 0.8);
    box-shadow: 
      0 0 20px color-mix(in oklch, var(--clr-neon-pink), transparent 50%),
      inset 0 0 20px color-mix(in oklch, var(--clr-neon-pink), transparent 70%);
  }

  .arcade-input::placeholder {
    color: color-mix(in oklch, white, transparent 50%);
  }

  /* Buttons */
  .arcade-btn {
    position: relative;
    padding-block: 0.75rem;
    padding-inline: 1.5rem;
    
    background: linear-gradient(135deg, var(--clr-neon-pink), var(--clr-neon-purple));
    border: 2px solid var(--clr-neon-cyan);
    border-radius: var(--radius-sm);
    color: white;
    
    font-family: inherit;
    font-weight: 700;
    font-size: var(--fs-sm);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    
    cursor: pointer;
    overflow: hidden;
    white-space: nowrap;
    
    transition: all var(--transition-base);
    box-shadow: 
      0 0 15px color-mix(in oklch, var(--clr-neon-pink), transparent 50%),
      0 4px 15px oklch(10% 0.03 255 / 0.5);
    
    contain: layout style paint;
    z-index: 1;
  }

	.arcade-btn::before {
	  content: '';
	  position: absolute;
	  top: 50%;
	  left: 50%;
	  inline-size: 0;
	  block-size: 0;
	  background: color-mix(in oklch, white, transparent 60%);
	  border-radius: var(--radius-full);
	  transform: translate(-50%, -50%);
	  transition: inline-size 800ms ease-out, block-size 800ms ease-out;
	  pointer-events: none;
	  z-index: 0;
	}

  .arcade-btn:hover {
    transform: translateY(-2px) scale(1.02);
    box-shadow: 
      0 8px 30px color-mix(in oklch, var(--clr-neon-pink), transparent 30%),
      0 0 30px color-mix(in oklch, var(--clr-neon-cyan), transparent 50%);
  }

  .arcade-btn:hover::before {
	  inline-size: 500px;
	  block-size: 500px;
	}

  .arcade-btn:active {
    transform: translateY(0) scale(0.98);
  }

  .arcade-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  .arcade-btn > * {
	  position: relative;
	  z-index: 2;
	}

  /* Game Cards */
  .games-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(min(300px, 100%), 1fr));
    gap: var(--space-lg);
    margin-block-end: var(--space-xl);
    container-type: inline-size;
  }

  .game-card {
    position: relative;
    background: var(--clr-card-bg);
    border: 2px solid transparent;
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    
    cursor: pointer;
    overflow: hidden;
    backdrop-filter: blur(12px);
    
    transition: all var(--transition-slow);
    box-shadow: 0 10px 30px oklch(5% 0.02 255 / 0.6);
    
    contain: layout style paint;
    content-visibility: auto;
    isolation: isolate;
  }

  .game-card::before {
    content: '';
    position: absolute;
    inset: 0px;
    border-radius: inherit;
    background: linear-gradient(
      135deg,
      var(--clr-neon-cyan),
      var(--clr-neon-pink),
      var(--clr-neon-purple)
    );
    background-size: 200% 200%;
    z-index: -1;
    opacity: 0.5;
    will-change: background-position, opacity;
    animation: borderGlow 8s ease-in-out infinite;
    mask: 
      linear-gradient(#fff 0 0) content-box, 
      linear-gradient(#fff 0 0);
    mask-composite: exclude;
    -webkit-mask: 
      linear-gradient(#fff 0 0) content-box, 
      linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    padding: 2px;
  }

  .game-card:hover {
    transform: translateY(-8px) scale(1.02);
    box-shadow: 
      0 20px 50px color-mix(in oklch, var(--clr-neon-cyan), transparent 50%),
      0 0 40px color-mix(in oklch, var(--clr-neon-pink), transparent 60%);
  }

  .game-card:hover::before {
    opacity: 1;
  }

  .game-icon {
    font-size: clamp(3.5rem, 12cqi, 5rem);
    text-align: center;
    margin-block-end: var(--space-sm);
    filter: drop-shadow(0 0 15px currentColor);
  }

  .game-card:nth-child(1) .game-icon {
    color: var(--clr-neon-yellow);
  }

  .game-card:nth-child(2) .game-icon {
    color: var(--clr-neon-pink);
  }

  .game-title {
    font-family: 'Press Start 2P', cursive;
    font-size: var(--fs-md);
    text-align: center;
    margin-block-end: var(--space-sm);
    color: var(--clr-neon-cyan);
    line-height: 1.6;
    text-shadow: 
      0 0 10px var(--clr-neon-cyan),
      0 0 20px color-mix(in oklch, var(--clr-neon-cyan), transparent 60%);
    word-wrap: break-word;
  }

  .game-description {
    text-align: center;
    opacity: 0.9;
    margin-block-end: var(--space-md);
    font-size: var(--fs-sm);
    line-height: 1.6;
    color: color-mix(in oklch, white, transparent 15%);
  }

  .game-stats-preview {
    display: flex;
    justify-content: space-around;
    padding: var(--space-sm);
    background: oklch(10% 0.03 255 / 0.5);
    border-radius: var(--radius-md);
    margin-block-end: var(--space-sm);
    gap: var(--space-sm);
    border: 2px solid color-mix(in oklch, var(--clr-neon-cyan), transparent 70%);
    box-shadow: 
      inset 0 0 20px color-mix(in oklch, var(--clr-neon-cyan), transparent 90%),
      0 0 10px color-mix(in oklch, var(--clr-neon-cyan), transparent 80%);
  }

  .stat-preview {
    text-align: center;
    flex: 1;
  }

  .stat-preview-value {
    font-size: var(--fs-lg);
    font-weight: 700;
    color: var(--clr-neon-yellow);
    text-shadow: 
      0 0 10px var(--clr-neon-yellow),
      0 0 20px color-mix(in oklch, var(--clr-neon-yellow), transparent 50%);
  }

  .stat-preview-label {
    font-size: var(--fs-xs);
    opacity: 0.7;
    text-transform: uppercase;
    margin-block-start: 0.25rem;
  }

  /* Modal */
  .modal {
    display: none;
    position: fixed;
    inset: 0;
    background: oklch(5% 0.02 255 / 0.95);
    z-index: var(--z-modal);
    backdrop-filter: blur(10px);
  }

  .modal.active {
    display: grid;
    place-items: center;
    padding: var(--space-md);
    animation: fadeIn 300ms ease;
  }

	.modal-content {
	  position: relative;
	  background: linear-gradient(
	    135deg,
	    oklch(15% 0.04 255 / 0.98),
	    oklch(20% 0.05 255 / 0.98)
	  );
	  border: 2px solid transparent;
	  border-radius: var(--radius-lg);
	  padding: var(--space-md); /* REDUCIDO de var(--space-lg) */
	  max-inline-size: min(850px, 96vw);
	  inline-size: 100%;
	  max-block-size: 92vh;
	  max-block-size: 92dvh;
	  
	  overflow-y: auto;
	  overscroll-behavior: contain;
	  
	  display: flex;
	  flex-direction: column;
	  gap: var(--space-sm); /* REDUCIDO de var(--space-md) */
	  
	  animation: slideUp 400ms cubic-bezier(0.4, 0, 0.2, 1);
	  contain: layout style paint;
	}

  .modal-content::before {
    content: '';
    position: absolute;
    inset: 0px;
    border-radius: inherit;
    background: linear-gradient(
      90deg,
      var(--clr-neon-cyan),
      var(--clr-neon-pink),
      var(--clr-neon-yellow),
      var(--clr-neon-cyan)
    );
    background-size: 200% 100%;
    z-index: -1;
    will-change: background-position;
    animation: borderFlow 6s linear infinite;
    mask: 
      linear-gradient(#fff 0 0) content-box, 
      linear-gradient(#fff 0 0);
    mask-composite: exclude;
    -webkit-mask: 
      linear-gradient(#fff 0 0) content-box, 
      linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    padding: 2px;
  }

  .modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-block-end: var(--space-sm);
    border-block-end: 2px solid var(--clr-neon-cyan);
    gap: var(--space-sm);
    box-shadow: 0 4px 15px color-mix(in oklch, var(--clr-neon-cyan), transparent 70%);
  }

  .modal-title {
    font-family: 'Press Start 2P', cursive;
    font-size: var(--fs-md);
    color: var(--clr-neon-yellow);
    line-height: 1.5;
    text-shadow: 
      0 0 10px var(--clr-neon-yellow),
      0 0 20px color-mix(in oklch, var(--clr-neon-yellow), transparent 50%);
    word-wrap: break-word;
    flex: 1;
  }

  .close-btn {
    background: transparent;
    border: 2px solid var(--clr-neon-pink);
    color: var(--clr-neon-pink);
    inline-size: clamp(42px, 10cqi, 50px);
    block-size: clamp(42px, 10cqi, 50px);
    border-radius: var(--radius-full);
    
    cursor: pointer;
    font-size: var(--fs-lg);
    transition: all var(--transition-base);
    flex-shrink: 0;
    
    display: grid;
    place-items: center;
    
    box-shadow: 
      0 0 15px color-mix(in oklch, var(--clr-neon-pink), transparent 50%),
      inset 0 0 10px color-mix(in oklch, var(--clr-neon-pink), transparent 80%);
  }

  .close-btn:hover {
    background: var(--clr-neon-pink);
    color: white;
    transform: rotate(90deg) scale(1.1);
    box-shadow: 0 0 25px var(--clr-neon-pink);
  }

  /* Game Stats */
	.game-stats {
	  display: flex;
	  justify-content: space-around;
	  flex-wrap: wrap;
	  padding: var(--space-sm); /* REDUCIDO de var(--space-md) */
	  background: oklch(10% 0.03 255 / 0.5);
	  border-radius: var(--radius-md);
	  gap: var(--space-sm); /* REDUCIDO de var(--space-md) */
	  border: 2px solid color-mix(in oklch, var(--clr-neon-cyan), transparent 60%);
	  box-shadow: 
	    inset 0 0 20px color-mix(in oklch, var(--clr-neon-cyan), transparent 85%),
	    0 0 15px color-mix(in oklch, var(--clr-neon-cyan), transparent 70%);
	  flex-shrink: 0;
	}

  .stat {
    text-align: center;
    flex: 1;
    min-inline-size: min(80px, 100%);
  }

	.stat-value {
	  font-size: var(--fs-lg); /* REDUCIDO de var(--fs-xl) */
	  font-weight: 700;
	  color: var(--clr-neon-yellow);
	  font-family: 'Press Start 2P', cursive;
	  text-shadow: 
	    0 0 12px var(--clr-neon-yellow),
	    0 0 24px color-mix(in oklch, var(--clr-neon-yellow), transparent 50%);
	}

  .stat-label {
    font-size: var(--fs-xs);
    opacity: 0.7;
    text-transform: uppercase;
    margin-block-start: 0.3rem;
  }

  /* Catch Game Area */
	.catch-game-area {
	  position: relative;
	  inline-size: 100%;
	  max-inline-size: min(650px, 100%);
	  margin-inline: auto;
	  block-size: clamp(220px, 35vh, 520px); /* M√ÅS REDUCIDO */
	  block-size: clamp(220px, 35dvh, 400px);
	  
	  background: linear-gradient(180deg, 
	    oklch(15% 0.05 255) 0%, 
	    oklch(18% 0.06 270) 100%);
	  border: 2px solid transparent;
	  border-radius: var(--radius-lg);
	  overflow: hidden;
	  flex-shrink: 0;
	  contain: layout style paint;
	}

  .catch-game-area::before {
    content: '';
    position: absolute;
    inset: 0px;
    border-radius: inherit;
    background: linear-gradient(
      45deg,
      var(--clr-neon-cyan),
      var(--clr-neon-pink),
      var(--clr-neon-yellow),
      var(--clr-neon-cyan)
    );
    background-size: 200% 200%;
    z-index: -1;
    will-change: background-position;
    animation: borderGlow 8s ease-in-out infinite;
    mask: 
      linear-gradient(#fff 0 0) content-box, 
      linear-gradient(#fff 0 0);
    mask-composite: exclude;
    -webkit-mask: 
      linear-gradient(#fff 0 0) content-box, 
      linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    padding: 2px;
  }

  .catch-game-area::after {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(
      circle at center,
      transparent 0%,
      color-mix(in oklch, var(--clr-neon-cyan), transparent 90%) 100%
    );
    pointer-events: none;
  }

  .catcher {
    position: absolute;
    inset-block-end: clamp(15px, 3vh, 25px);
    inline-size: clamp(55px, 11vw, 75px);
    block-size: clamp(55px, 11vw, 75px);
    font-size: clamp(2.2rem, 5.5vw, 3rem);
    
    cursor: move;
    touch-action: none;
    user-select: none;
    
    filter: drop-shadow(0 0 12px var(--clr-neon-yellow));
    z-index: 100;
    
    display: grid;
    place-items: center;
    contain: layout style paint;
    will-change: transform;
  }

  .falling-item {
    position: absolute;
    font-size: clamp(1.8rem, 4.5vw, 2.5rem);
    pointer-events: none;
    user-select: none;
    filter: drop-shadow(0 0 8px currentColor);
    will-change: transform;
    animation: itemSpin 2s linear infinite;
  }

  .powerup {
    animation: itemSpin 2s linear infinite, powerupPulse 1s ease-in-out infinite;
  }

  /* Memory Game */
	.memory-grid {
	  display: grid;
	  grid-template-columns: repeat(4, minmax(0, 1fr)); /* CAMBIO CLAVE: minmax(0, 1fr) */
	  gap: clamp(0.4rem, 2cqi, 0.9rem);
	  max-inline-size: min(420px, 95%); /* REDUCIDO de 480px y cambiado a 95% */
	  inline-size: 100%; /* A√ëADIDO */
	  margin-inline: auto;
	  margin-block-end: var(--space-md);
	  padding-inline: var(--space-xs); /* A√ëADIDO padding */
	  flex-shrink: 0;
	  container-type: inline-size;
	  place-items: center; /* A√ëADIDO */
	}

	.memory-card {
	  aspect-ratio: 1;
	  inline-size: 100%; /* A√ëADIDO */
	  max-inline-size: 90px; /* A√ëADIDO l√≠mite */
	  min-block-size: clamp(55px, 15cqi, 90px);
	  
	  background: linear-gradient(135deg, 
	    color-mix(in oklch, var(--clr-neon-cyan), transparent 80%),
	    color-mix(in oklch, var(--clr-neon-purple), transparent 80%));
	  border: 3px solid var(--clr-neon-cyan);
	  border-radius: var(--radius-md);
	  
	  cursor: pointer;
	  user-select: none;
	  
	  display: grid;
	  place-items: center;
	  font-size: clamp(1.8rem, 6cqi, 3rem);
	  
	  transition: all var(--transition-slow);
	  box-shadow: 
	    0 0 15px color-mix(in oklch, var(--clr-neon-cyan), transparent 60%),
	    inset 0 0 15px color-mix(in oklch, var(--clr-neon-cyan), transparent 85%);
	  
	  contain: layout style paint;
	}

  .memory-card:hover:not(.flipped):not(.matched) {
    transform: scale(1.05);
    border-color: var(--clr-neon-pink);
    box-shadow: 
      0 0 25px color-mix(in oklch, var(--clr-neon-pink), transparent 40%),
      inset 0 0 20px color-mix(in oklch, var(--clr-neon-pink), transparent 70%);
  }

  .memory-card.flipped {
    background: linear-gradient(135deg, 
      color-mix(in oklch, var(--clr-neon-pink), transparent 50%),
      color-mix(in oklch, var(--clr-neon-purple), transparent 50%));
    border-color: var(--clr-neon-pink);
    transform: rotateY(180deg);
    box-shadow: 
      0 0 25px color-mix(in oklch, var(--clr-neon-pink), transparent 40%),
      inset 0 0 25px color-mix(in oklch, var(--clr-neon-pink), transparent 70%);
  }

  .memory-card.matched {
    background: linear-gradient(135deg, 
      color-mix(in oklch, var(--clr-neon-cyan), transparent 50%),
      color-mix(in oklch, var(--clr-neon-yellow), transparent 50%));
    border-color: var(--clr-neon-yellow);
    cursor: default;
    animation: matchFlash 600ms ease;
    box-shadow: 
      0 0 30px var(--clr-neon-yellow),
      inset 0 0 25px color-mix(in oklch, var(--clr-neon-yellow), transparent 60%);
  }

  /* Leaderboard */
  .leaderboard-section {
    position: relative;
    background: var(--clr-card-bg);
    border: 2px solid transparent;
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
    backdrop-filter: blur(12px);
    contain: layout style paint;
    isolation: isolate;
  }

  .leaderboard-section::before {
    content: '';
    position: absolute;
    inset: 0px;
    border-radius: inherit;
    background: linear-gradient(
      135deg,
      var(--clr-neon-purple),
      var(--clr-neon-pink),
      var(--clr-neon-cyan),
      var(--clr-neon-purple)
    );
    background-size: 200% 200%;
    z-index: -1;
    will-change: background-position;
    animation: borderGlow 10s ease-in-out infinite;
    mask: 
      linear-gradient(#fff 0 0) content-box, 
      linear-gradient(#fff 0 0);
    mask-composite: exclude;
    -webkit-mask: 
      linear-gradient(#fff 0 0) content-box, 
      linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    padding: 2px;
  }

  .leaderboard-title {
    font-family: 'Press Start 2P', cursive;
    font-size: var(--fs-lg);
    text-align: center;
    margin-block-end: var(--space-lg);
    color: var(--clr-neon-yellow);
    line-height: 1.5;
    text-shadow: 
      0 0 15px var(--clr-neon-yellow),
      0 0 30px color-mix(in oklch, var(--clr-neon-yellow), transparent 50%);
    word-wrap: break-word;
  }

  .leaderboard-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(min(280px, 100%), 1fr));
    gap: var(--space-lg);
  }

  .leaderboard-box {
    background: oklch(10% 0.03 255 / 0.5);
    border: 2px solid color-mix(in oklch, var(--clr-neon-cyan), transparent 60%);
    border-radius: var(--radius-lg);
    padding: var(--space-md);
    box-shadow: 
      0 0 20px color-mix(in oklch, var(--clr-neon-cyan), transparent 70%),
      inset 0 0 25px color-mix(in oklch, var(--clr-neon-cyan), transparent 90%);
  }

  .leaderboard-box h3 {
    text-align: center;
    color: var(--clr-neon-pink);
    margin-block-end: var(--space-md);
    font-size: var(--fs-md);
    text-shadow: 
      0 0 12px var(--clr-neon-pink),
      0 0 24px color-mix(in oklch, var(--clr-neon-pink), transparent 50%);
    word-wrap: break-word;
  }

  .leaderboard-list {
    list-style: none;
  }

  .leaderboard-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--space-sm);
    margin-block-end: var(--space-xs);
    background: color-mix(in oklch, var(--clr-neon-cyan), transparent 92%);
    border: 2px solid color-mix(in oklch, var(--clr-neon-cyan), transparent 70%);
    border-radius: var(--radius-md);
    gap: var(--space-xs);
    transition: all var(--transition-base);
    contain: layout style paint;
  }

  .leaderboard-item:hover {
    background: color-mix(in oklch, var(--clr-neon-cyan), transparent 80%);
    transform: translateX(8px) scale(1.02);
    border-color: var(--clr-neon-cyan);
    box-shadow: 0 0 20px color-mix(in oklch, var(--clr-neon-cyan), transparent 50%);
  }

  .leaderboard-item.top-1 {
    background: linear-gradient(135deg, 
      oklch(70% 0.15 85 / 0.4),
      oklch(65% 0.12 85 / 0.3));
    border: 2px solid oklch(80% 0.15 85);
    box-shadow: 
      0 0 25px oklch(80% 0.15 85 / 0.6),
      inset 0 0 20px oklch(80% 0.15 85 / 0.2);
  }

  .leaderboard-item.top-2 {
    background: linear-gradient(135deg, 
      oklch(75% 0.01 0 / 0.4),
      oklch(70% 0.01 0 / 0.3));
    border: 2px solid oklch(80% 0.01 0);
    box-shadow: 
      0 0 25px oklch(80% 0.01 0 / 0.6),
      inset 0 0 20px oklch(80% 0.01 0 / 0.2);
  }

  .leaderboard-item.top-3 {
    background: linear-gradient(135deg, 
      oklch(60% 0.12 55 / 0.4),
      oklch(55% 0.10 55 / 0.3));
    border: 2px solid oklch(65% 0.12 55);
    box-shadow: 
      0 0 25px oklch(65% 0.12 55 / 0.6),
      inset 0 0 20px oklch(65% 0.12 55 / 0.2);
  }

  .leaderboard-rank {
    font-size: var(--fs-md);
    font-weight: 700;
    min-inline-size: clamp(35px, 10cqi, 50px);
    text-align: center;
    text-shadow: 0 0 8px currentColor;
  }

  .leaderboard-name {
    flex: 1;
    margin-inline: var(--space-xs);
    font-weight: 600;
    font-size: var(--fs-sm);
    word-break: break-word;
    overflow-wrap: break-word;
  }

  .leaderboard-score {
    font-size: var(--fs-md);
    font-weight: 700;
    color: var(--clr-neon-yellow);
    text-shadow: 
      0 0 10px var(--clr-neon-yellow),
      0 0 20px color-mix(in oklch, var(--clr-neon-yellow), transparent 50%);
  }

  .no-scores {
    text-align: center;
    opacity: 0.5;
    padding: var(--space-lg);
    font-style: italic;
    font-size: var(--fs-sm);
  }

  /* Game Over Alert */
  .game-over-alert {
    position: fixed;
    inset-block-start: 50%;
    inset-inline-start: 50%;
    transform: translate(-50%, -50%) scale(0);
    
    background: linear-gradient(135deg, 
      var(--clr-neon-purple), 
      var(--clr-neon-pink));
    padding: var(--space-xl);
    border-radius: var(--radius-lg);
    border: 3px solid var(--clr-neon-cyan);
    
    box-shadow: 
      0 0 80px color-mix(in oklch, var(--clr-neon-cyan), transparent 20%),
      0 0 50px color-mix(in oklch, var(--clr-neon-pink), transparent 40%),
      inset 0 0 30px color-mix(in oklch, white, transparent 70%);
    
    text-align: center;
    z-index: var(--z-alert);
    max-inline-size: min(480px, 92vw);
    
    transition: transform var(--transition-slow);
    contain: layout style paint;
  }

  .game-over-alert.active {
    transform: translate(-50%, -50%) scale(1);
    animation: alertPulse 1s ease-in-out;
  }

  .game-over-alert h2 {
    font-family: 'Press Start 2P', cursive;
    font-size: var(--fs-xl);
    margin-block-end: var(--space-sm);
    color: var(--clr-neon-yellow);
    line-height: 1.5;
    text-shadow: 
      0 0 20px var(--clr-neon-yellow),
      0 0 40px color-mix(in oklch, white, transparent 20%);
    word-wrap: break-word;
  }

  .final-score-display {
    font-size: var(--fs-3xl);
    font-weight: 900;
    color: white;
    margin-block: var(--space-sm);
    text-shadow: 
      0 0 25px white,
      0 0 50px var(--clr-neon-cyan),
      0 0 75px color-mix(in oklch, var(--clr-neon-pink), transparent 40%);
  }

  /* Scrollbar */
  .modal-content::-webkit-scrollbar {
    inline-size: 10px;
  }

  .modal-content::-webkit-scrollbar-track {
    background: oklch(10% 0.03 255 / 0.4);
    border-radius: var(--radius-sm);
    box-shadow: inset 0 0 8px color-mix(in oklch, var(--clr-neon-cyan), transparent 80%);
  }

  .modal-content::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, 
      var(--clr-neon-cyan), 
      var(--clr-neon-purple));
    border-radius: var(--radius-sm);
    box-shadow: 0 0 8px color-mix(in oklch, var(--clr-neon-cyan), transparent 40%);
  }

  .modal-content::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, 
      var(--clr-neon-pink), 
      var(--clr-neon-yellow));
    box-shadow: 0 0 12px var(--clr-neon-pink);
  }

  /* Scrollbar for Firefox */
  .modal-content {
    scrollbar-width: thin;
    scrollbar-color: var(--clr-neon-cyan) oklch(10% 0.03 255 / 0.4);
  }

  .modal-content > div:last-of-type {
	  flex-shrink: 0; /* Evitar que se comprima */
	  margin-block-start: auto; /* Empujar hacia abajo si hay espacio */
	}

	/* Neon Runner Game */
	.runner-game-area {
	    position: relative;
	    inline-size: 100%;
	    max-inline-size: min(650px, 100%);
	    margin-inline: auto;
	    block-size: clamp(220px, 35vh, 400px);
	    
	    background: linear-gradient(180deg, 
	        oklch(15% 0.05 255) 0%, 
	        oklch(18% 0.06 270) 100%);
	    border: 2px solid transparent;
	    border-radius: var(--radius-lg);
	    overflow: hidden;
	    flex-shrink: 0;
	    contain: layout style paint;
	}

	.runner-game-area::before {
	    content: '';
	    position: absolute;
	    inset: 0px;
	    border-radius: inherit;
	    background: linear-gradient(
	        45deg,
	        var(--clr-neon-cyan),
	        var(--clr-neon-pink),
	        var(--clr-neon-yellow),
	        var(--clr-neon-cyan)
	    );
	    background-size: 200% 200%;
	    z-index: -1;
	    will-change: background-position;
	    animation: borderGlow 8s ease-in-out infinite;
	    mask: 
	        linear-gradient(#fff 0 0) content-box, 
	        linear-gradient(#fff 0 0);
	    mask-composite: exclude;
	    -webkit-mask: 
	        linear-gradient(#fff 0 0) content-box, 
	        linear-gradient(#fff 0 0);
	    -webkit-mask-composite: xor;
	    padding: 2px;
	}

	.runner-ground {
	    position: absolute;
	    inset-block-end: 0;
	    inline-size: 100%;
	    block-size: 4px;
	    background: linear-gradient(90deg, 
	        var(--clr-neon-cyan), 
	        var(--clr-neon-pink), 
	        var(--clr-neon-yellow));
	    background-size: 200% 100%;
	    animation: groundScroll 1s linear infinite;
	    box-shadow: 0 0 15px var(--clr-neon-cyan);
	}

	.runner-player {
	    position: absolute;
	    inset-block-end: 4px;
	    inset-inline-start: clamp(40px, 10%, 80px);
	    inline-size: clamp(45px, 10vw, 60px);
	    block-size: clamp(45px, 10vw, 60px);
	    font-size: clamp(2rem, 5vw, 2.5rem);
	    
	    display: grid;
	    place-items: center;
	    
	    filter: drop-shadow(0 0 12px var(--clr-neon-yellow));
	    z-index: 10;
	    
	    contain: layout style paint;
	    will-change: transform;
	    transition: transform 0.1s ease-out;
	}

	.runner-player.jumping {
	    animation: playerJump 0.5s ease-out;
	}

	.runner-obstacle {
	    position: absolute;
	    inset-block-end: 4px;
	    inline-size: clamp(35px, 8vw, 50px);
	    block-size: clamp(35px, 8vw, 50px);
	    font-size: clamp(1.5rem, 4vw, 2rem);
	    
	    display: grid;
	    place-items: center;
	    
	    filter: drop-shadow(0 0 8px currentColor);
	    will-change: transform;
	    animation: obstacleMove linear;
	}

	/* Space Invaders Game */
.invaders-game-area {
    position: relative;
    inline-size: 100%;
    max-inline-size: min(650px, 100%);
    margin-inline: auto;
    block-size: clamp(300px, 45vh, 500px);
    
    background: linear-gradient(180deg, 
        oklch(5% 0.08 270) 0%, 
        oklch(10% 0.05 255) 50%,
        oklch(15% 0.05 255) 100%);
    border: 2px solid transparent;
    border-radius: var(--radius-lg);
    overflow: hidden;
    flex-shrink: 0;
    contain: layout style paint;
}

.invaders-game-area::before {
    content: '';
    position: absolute;
    inset: 0px;
    border-radius: inherit;
    background: linear-gradient(
        45deg,
        var(--clr-neon-purple),
        var(--clr-neon-pink),
        var(--clr-neon-cyan),
        var(--clr-neon-purple)
    );
    background-size: 200% 200%;
    z-index: -1;
    will-change: background-position;
    animation: borderGlow 8s ease-in-out infinite;
    mask: 
        linear-gradient(#fff 0 0) content-box, 
        linear-gradient(#fff 0 0);
    mask-composite: exclude;
    -webkit-mask: 
        linear-gradient(#fff 0 0) content-box, 
        linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    padding: 2px;
}

.invaders-player {
    position: absolute;
    inset-block-end: 20px;
    inline-size: clamp(40px, 8vw, 55px);
    block-size: clamp(40px, 8vw, 55px);
    font-size: clamp(1.8rem, 4vw, 2.5rem);
    
    display: grid;
    place-items: center;
    
    filter: drop-shadow(0 0 15px var(--clr-neon-cyan));
    z-index: 10;
    
    contain: layout style paint;
    will-change: transform;
    transition: left 0.1s ease-out;
}

.invader {
    position: absolute;
    inline-size: clamp(30px, 6vw, 45px);
    block-size: clamp(30px, 6vw, 45px);
    font-size: clamp(1.5rem, 3.5vw, 2rem);
    
    display: grid;
    place-items: center;
    
    filter: drop-shadow(0 0 8px var(--clr-neon-pink));
    will-change: transform;
    animation: invaderFloat 2s ease-in-out infinite;
}

.bullet {
    position: absolute;
    inline-size: 4px;
    block-size: clamp(12px, 3vw, 18px);
    background: linear-gradient(180deg, 
        var(--clr-neon-yellow), 
        var(--clr-neon-cyan));
    border-radius: var(--radius-full);
    box-shadow: 
        0 0 10px var(--clr-neon-yellow),
        0 0 20px var(--clr-neon-cyan);
    will-change: transform;
}

.enemy-bullet {
    background: linear-gradient(180deg, 
        var(--clr-neon-pink), 
        var(--clr-neon-purple));
    box-shadow: 
        0 0 10px var(--clr-neon-pink),
        0 0 20px var(--clr-neon-purple);
}

.explosion {
    position: absolute;
    font-size: clamp(2rem, 5vw, 3rem);
    pointer-events: none;
    animation: explode 0.5s ease-out forwards;
    z-index: 100;
}
}

/* ============================================
   LAYER: ANIMATIONS
============================================ */
@layer animations {
  
  @keyframes gridMove {
    from { transform: perspective(500px) rotateX(60deg) translateY(0); }
    to { transform: perspective(500px) rotateX(60deg) translateY(50px); }
  }

  @keyframes particleFloat {
    0%, 100% { 
      background-position: 0% 0%, 100% 100%, 50% 50%; 
    }
    33% { 
      background-position: 100% 0%, 0% 50%, 80% 20%; 
    }
    66% { 
      background-position: 0% 100%, 100% 20%, 20% 80%; 
    }
  }

  @keyframes lightRotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  @keyframes twinkle {
    0%, 100% { 
      opacity: 0.3; 
      transform: scale(0.9);
    }
    50% { 
      opacity: 1; 
      transform: scale(1.1);
    }
  }

  @keyframes gradientFlow {
    from { background-position: 0% center; }
    to { background-position: 200% center; }
  }

  @keyframes borderFlow {
    from { background-position: 0% center; }
    to { background-position: 200% center; }
  }

  @keyframes borderGlow {
    0%, 100% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
  }

  @keyframes itemSpin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  @keyframes powerupPulse {
    0%, 100% { 
      transform: scale(1); 
      filter: drop-shadow(0 0 8px currentColor);
    }
    50% { 
      transform: scale(1.15); 
      filter: drop-shadow(0 0 16px currentColor);
    }
  }

  @keyframes matchFlash {
    0% { 
      transform: scale(1); 
      filter: brightness(1);
    }
    25% { 
      transform: scale(1.15) rotate(5deg); 
      filter: brightness(1.5);
    }
    50% { 
      transform: scale(1.1) rotate(-5deg); 
      filter: brightness(2);
    }
    75% { 
      transform: scale(1.15) rotate(3deg); 
      filter: brightness(1.5);
    }
    100% { 
      transform: scale(1) rotate(0deg); 
      filter: brightness(1);
    }
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  @keyframes slideUp {
    from { 
      transform: translateY(20px); 
      opacity: 0; 
    }
    to { 
      transform: translateY(0); 
      opacity: 1; 
    }
  }

  @keyframes alertPulse {
    0% { 
      transform: translate(-50%, -50%) scale(0) rotate(0deg); 
    }
    50% { 
      transform: translate(-50%, -50%) scale(1.08) rotate(3deg); 
    }
    75% { 
      transform: translate(-50%, -50%) scale(0.96) rotate(-2deg); 
    }
    100% { 
      transform: translate(-50%, -50%) scale(1) rotate(0deg); 
    }
  }

  @keyframes groundScroll {
	    from { background-position: 0% center; }
	    to { background-position: 200% center; }
	}

	@keyframes playerJump {
	    0% { transform: translateY(0); }
	    50% { transform: translateY(-120px); }
	    100% { transform: translateY(0); }
	}

	@keyframes obstacleMove {
	    from { transform: translateX(0); }
	    to { transform: translateX(-100vw); }
	}

	@keyframes invaderFloat {
	    0%, 100% { transform: translateY(0) rotate(0deg); }
	    50% { transform: translateY(-5px) rotate(5deg); }
	}

	@keyframes explode {
	    0% { 
	        transform: scale(0.5); 
	        opacity: 1; 
	    }
	    100% { 
	        transform: scale(2); 
	        opacity: 0; 
	    }
	}
}

/* ============================================
   LAYER: UTILITIES
============================================ */
@layer utilities {
  
  .visually-hidden {
    position: absolute;
    inline-size: 1px;
    block-size: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }

  .skip-to-content {
    position: absolute;
    inset-block-start: -100%;
    inset-inline-start: 50%;
    transform: translateX(-50%);
    padding: var(--space-sm) var(--space-md);
    background: var(--clr-neon-cyan);
    color: var(--clr-bg-darker);
    font-weight: 700;
    border-radius: var(--radius-sm);
    z-index: var(--z-modal);
    transition: inset-block-start var(--transition-base);
  }

  .skip-to-content:focus {
    inset-block-start: var(--space-sm);
  }
}

/* ============================================
   RESPONSIVE & ACCESSIBILITY
============================================ */

/* Reduced Motion */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
}

/* High Contrast */
@media (prefers-contrast: high) {
  .game-card,
  .user-panel,
  .leaderboard-section,
  .modal-content {
    border-width: 4px;
  }
  
  .stat-value,
  .leaderboard-score,
  .final-score-display {
    font-weight: 900;
  }
}

/* Touch Devices */
@media (hover: none) and (pointer: coarse) {
  .game-card,
  .arcade-btn,
  .memory-card,
  .leaderboard-item,
  .close-btn {
    transition-duration: 100ms;
  }
  
  .game-card:active {
    transform: scale(0.98);
  }
  
  .arcade-btn:active {
    transform: scale(0.96);
  }
  
  .memory-card:active:not(.flipped):not(.matched) {
    transform: scale(0.95);
  }
  
  .close-btn:active {
    transform: scale(0.95) rotate(90deg);
  }
}

/* Container Queries */
@container (inline-size < 400px) {
  .memory-grid {
    gap: 0.3rem;
  }
  
  .game-stats {
    flex-direction: column;
  }
  
  .stat {
    min-inline-size: 100%;
  }
}

@container (inline-size > 800px) {
  .games-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* Print Styles */
@media print {
  .animated-bg,
  .arcade-btn,
  .close-btn {
    display: none;
  }
  
  body {
    background: white;
    color: black;
  }
  
  .game-card,
  .leaderboard-section {
    break-inside: avoid;
  }
}
</style>
<script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-firestore-compat.js"></script>

<script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-auth-compat.js"></script>
</head>
<body>
	<!-- Animated Background Layer -->
	<div class="animated-bg">
		<div class="grid-lines"></div>
		<div class="stars" id="starsContainer"></div>
	</div>

	<!-- Skip to main content for accessibility -->
	<a href="#main-content" class="skip-to-content">Skip to main content</a>

	<div class="container">
		<!-- Header Section -->
		<header class="header">
			<h1 data-text="ARCADE ZONE">ARCADE ZONE</h1>
			<p>‚óÜ ELITE MULTIPLAYER ARENA ‚óÜ</p>
		</header>

		<!-- User Authentication Panel -->
		<section class="user-panel" aria-label="User authentication">
			<div id="loginView">
				<button class="arcade-btn" onclick="loginWithGoogle()" aria-label="Sign in with Google">
					<span aria-hidden="true">‚òÖ</span> SIGN IN WITH GOOGLE <span aria-hidden="true">‚òÖ</span>
				</button>
			</div>

			<div id="userView" style="display: none;">
				<div class="user-info">
					<div class="user-avatar" aria-hidden="true">üéÆ</div>
					<div>
						<div class="user-name" id="displayUsername"></div>
						<div style="font-size: 0.8rem; opacity: 0.7;">ACTIVE PLAYER</div>
					</div>
				</div>
				<button class="arcade-btn" onclick="logout()" aria-label="Logout from account">
					<span aria-hidden="true">‚èè</span> LOGOUT
				</button>
			</div>
		</section>

		<!-- Main Games Grid -->
		<main id="main-content" class="games-grid">
			<!-- Star Catcher Game Card -->
			<article class="game-card" onclick="openGame('catch')" tabindex="0" role="button" aria-label="Play Star Catcher game">
				<div class="game-icon" aria-hidden="true">‚≠ê</div>
				<h2 class="game-title">STAR CATCHER</h2>
				<p class="game-description">
					Catch falling stars and power-ups! Dodge deadly bombs and chase the highest score in this fast-paced arcade challenge.
				</p>
				<div class="game-stats-preview" aria-label="Star Catcher statistics">
					<div class="stat-preview">
						<div class="stat-preview-value" id="catchBestPreview">-</div>
						<div class="stat-preview-label">Your Best</div>
					</div>
					<div class="stat-preview">
						<div class="stat-preview-value" id="catchWorldPreview">-</div>
						<div class="stat-preview-label">World #1</div>
					</div>
				</div>
				<div style="text-align: center; margin-top: 1rem;">
					<button class="arcade-btn" onclick="event.stopPropagation(); openGame('catch')" aria-label="Start Star Catcher">
						<span aria-hidden="true">‚ñ∂</span> PLAY NOW
					</button>
				</div>
			</article>

			<!-- Memory Master Game Card -->
			<article class="game-card" onclick="openGame('memory')" tabindex="0" role="button" aria-label="Play Memory Master game">
				<div class="game-icon" aria-hidden="true">üß†</div>
				<h2 class="game-title">MEMORY MASTER</h2>
				<p class="game-description">
					Test your memory skills! Match all emoji pairs with the fewest moves possible. Can you achieve perfection?
				</p>
				<div class="game-stats-preview" aria-label="Memory Master statistics">
					<div class="stat-preview">
						<div class="stat-preview-value" id="memoryBestPreview">-</div>
						<div class="stat-preview-label">Your Best</div>
					</div>
					<div class="stat-preview">
						<div class="stat-preview-value" id="memoryWorldPreview">-</div>
						<div class="stat-preview-label">World #1</div>
					</div>
				</div>
				<div style="text-align: center; margin-top: 1rem;">
					<button class="arcade-btn" onclick="event.stopPropagation(); openGame('memory')" aria-label="Start Memory Master">
						<span aria-hidden="true">‚ñ∂</span> PLAY NOW
					</button>
				</div>
			</article>

			<!-- Neon Runner Game Card -->
			<article class="game-card" onclick="openGame('runner')" tabindex="0" role="button" aria-label="Play Neon Runner game">
			    <div class="game-icon" aria-hidden="true">üèÉ</div>
			    <h2 class="game-title">NEON RUNNER</h2>
			    <p class="game-description">
			        Jump over obstacles in this endless runner! Time your jumps perfectly and survive as long as possible.
			    </p>
			    <div class="game-stats-preview" aria-label="Neon Runner statistics">
			        <div class="stat-preview">
			            <div class="stat-preview-value" id="runnerBestPreview">-</div>
			            <div class="stat-preview-label">Your Best</div>
			        </div>
			        <div class="stat-preview">
			            <div class="stat-preview-value" id="runnerWorldPreview">-</div>
			            <div class="stat-preview-label">World #1</div>
			        </div>
			    </div>
			    <div style="text-align: center; margin-top: 1rem;">
			        <button class="arcade-btn" onclick="event.stopPropagation(); openGame('runner')" aria-label="Start Neon Runner">
			            <span aria-hidden="true">‚ñ∂</span> PLAY NOW
			        </button>
			    </div>
			</article>

			<!-- Space Invaders Game Card -->
			<article class="game-card" onclick="openGame('invaders')" tabindex="0" role="button" aria-label="Play Space Invaders Remix game">
			    <div class="game-icon" aria-hidden="true">üëæ</div>
			    <h2 class="game-title">SPACE INVADERS</h2>
			    <p class="game-description">
			        Defend Earth from alien invaders! Shoot them down before they reach your base. Classic arcade action!
			    </p>
			    <div class="game-stats-preview" aria-label="Space Invaders statistics">
			        <div class="stat-preview">
			            <div class="stat-preview-value" id="invadersBestPreview">-</div>
			            <div class="stat-preview-label">Your Best</div>
			        </div>
			        <div class="stat-preview">
			            <div class="stat-preview-value" id="invadersWorldPreview">-</div>
			            <div class="stat-preview-label">World #1</div>
			        </div>
			    </div>
			    <div style="text-align: center; margin-top: 1rem;">
			        <button class="arcade-btn" onclick="event.stopPropagation(); openGame('invaders')" aria-label="Start Space Invaders">
			            <span aria-hidden="true">‚ñ∂</span> PLAY NOW
			        </button>
			    </div>
			</article>
		</main>

		<!-- Global Leaderboard Section -->
		<section class="leaderboard-section" aria-label="Global leaderboards">
    <h2 class="leaderboard-title">‚óÜ GLOBAL RANKINGS ‚óÜ</h2>

    <!-- FILA 1 -->
    <div class="leaderboard-grid">
        <div class="leaderboard-box">
            <h3><span aria-hidden="true">‚≠ê</span> STAR CATCHER</h3>
            <ul class="leaderboard-list" id="catchLeaderboard" role="list">
                <li class="no-scores">Loading rankings...</li>
            </ul>
        </div>

        <div class="leaderboard-box">
            <h3><span aria-hidden="true">üß†</span> MEMORY MASTER</h3>
            <ul class="leaderboard-list" id="memoryLeaderboard" role="list">
                <li class="no-scores">Loading rankings...</li>
            </ul>
        </div>
    </div>

    <!-- FILA 2 -->
    <div class="leaderboard-grid">
        <div class="leaderboard-box">
            <h3><span aria-hidden="true">üèÉ</span> NEON RUNNER</h3>
            <ul class="leaderboard-list" id="runnerLeaderboard" role="list">
                <li class="no-scores">Loading rankings...</li>
            </ul>
        </div>

        <div class="leaderboard-box">
            <h3><span aria-hidden="true">üëæ</span> SPACE INVADERS</h3>
            <ul class="leaderboard-list" id="invadersLeaderboard" role="list">
                <li class="no-scores">Loading rankings...</li>
            </ul>
        </div>
    </div>
</section>

	</div>

	<!-- Star Catcher Game Modal -->
	<div class="modal" id="catchModal" role="dialog" aria-labelledby="catchModalTitle" aria-modal="true">
		<div class="modal-content">
			<div class="modal-header">
				<h2 class="modal-title" id="catchModalTitle"><span aria-hidden="true">‚≠ê</span> STAR CATCHER</h2>
				<button class="close-btn" onclick="closeGame('catch')" aria-label="Close game">√ó</button>
			</div>

			<div class="game-stats" role="status" aria-live="polite">
				<div class="stat">
					<div class="stat-value" id="catchScore" aria-label="Current score">0</div>
					<div class="stat-label">Score</div>
				</div>
				<div class="stat">
					<div class="stat-value" id="catchTime" aria-label="Time remaining">30</div>
					<div class="stat-label">Time</div>
				</div>
				<div class="stat">
					<div class="stat-value" id="catchMultiplier" aria-label="Score multiplier">x1</div>
					<div class="stat-label">Combo</div>
				</div>
			</div>

			<div class="catch-game-area" id="catchGameArea" role="application" aria-label="Game area">
				<div class="catcher" id="catcher" aria-label="Player catcher">üéØ</div>
			</div>

			<div style="text-align: center;">
				<button class="arcade-btn" onclick="startCatchGame()" id="catchStartBtn">
					<span aria-hidden="true">üöÄ</span> START GAME
				</button>
			</div>

			<div style="margin-top: 2rem; padding: 1rem; background: rgba(0,0,0,0.3); border-radius: 10px; font-size: 0.9rem; line-height: 1.6;">
			    <strong style="color: var(--clr-neon-cyan);">üíé POWER-UPS GUIDE:</strong><br>
			
			    <div style="display: flex; gap: 0.8rem; flex-wrap: wrap; font-size: 0.8rem; margin-top: 0.5rem;">
			
			        <div style="white-space: nowrap;">
			            <span aria-hidden="true">‚ö°</span>
			            <strong>Speed Boost</strong> ‚Äì Faster star fall
			        </div>
			        <div style="white-space: nowrap;">
			            <span aria-hidden="true">üåü</span>
			            <strong>Double Points</strong> ‚Äì Score multiplier x2
			        </div>
			        <div style="white-space: nowrap;">
			            <span aria-hidden="true">‚è∞</span>
			            <strong>Time Extension</strong> ‚Äì +10 seconds bonus
			        </div>
			        <div style="white-space: nowrap;">
			            <span aria-hidden="true">üõ°Ô∏è</span>
			            <strong>Shield</strong> ‚Äì Bomb protection
			        </div>
			    </div>
			</div>
		</div>
	</div>

	<!-- Memory Master Game Modal -->
	<div class="modal" id="memoryModal" role="dialog" aria-labelledby="memoryModalTitle" aria-modal="true">
		<div class="modal-content">
			<div class="modal-header">
				<h2 class="modal-title" id="memoryModalTitle"><span aria-hidden="true">üß†</span> MEMORY MASTER</h2>
				<button class="close-btn" onclick="closeGame('memory')" aria-label="Close game">√ó</button>
			</div>

			<div class="game-stats" role="status" aria-live="polite">
				<div class="stat">
					<div class="stat-value" id="memoryMoves" aria-label="Total moves">0</div>
					<div class="stat-label">Moves</div>
				</div>
				<div class="stat">
					<div class="stat-value" id="memoryPairs" aria-label="Pairs matched">0/8</div>
					<div class="stat-label">Matched</div>
				</div>
			</div>

			<div class="memory-grid" id="memoryGrid" role="application" aria-label="Memory game grid"></div>

			<div style="text-align: center;">
				<button class="arcade-btn" onclick="initMemoryGame()">
					<span aria-hidden="true">üîÑ</span> NEW GAME
				</button>
			</div>

			<div style="margin-top: 1.5rem; padding: 1rem; background: rgba(0,0,0,0.3); border-radius: 10px; font-size: 0.85rem; text-align: center; opacity: 0.8;">
				<strong>Pro tip:</strong> Focus on patterns and positions. The fewer moves, the better your score!
			</div>
		</div>
	</div>

	<!-- Neon Runner Game Modal -->
	<div class="modal" id="runnerModal" role="dialog" aria-labelledby="runnerModalTitle" aria-modal="true">
	    <div class="modal-content">
	        <div class="modal-header">
	            <h2 class="modal-title" id="runnerModalTitle"><span aria-hidden="true">üèÉ</span> NEON RUNNER</h2>
	            <button class="close-btn" onclick="closeGame('runner')" aria-label="Close game">√ó</button>
	        </div>

	        <div class="game-stats" role="status" aria-live="polite">
	            <div class="stat">
	                <div class="stat-value" id="runnerScore" aria-label="Current score">0</div>
	                <div class="stat-label">Distance</div>
	            </div>
	            <div class="stat">
	                <div class="stat-value" id="runnerSpeed" aria-label="Current speed">1.0x</div>
	                <div class="stat-label">Speed</div>
	            </div>
	        </div>

	        <div class="runner-game-area" id="runnerGameArea" role="application" aria-label="Game area">
	            <div class="runner-player" id="runnerPlayer" aria-label="Player character">üèÉ</div>
	            <div class="runner-ground"></div>
	        </div>

	        <div style="text-align: center;">
	            <button class="arcade-btn" onclick="startRunnerGame()" id="runnerStartBtn">
	                <span aria-hidden="true">üöÄ</span> START RUNNING
	            </button>
	        </div>

	        <div style="margin-top: 2rem; padding: 1rem; background: rgba(0,0,0,0.3); border-radius: 10px; font-size: 0.9rem; line-height: 1.6;">
	            <strong style="color: var(--clr-neon-cyan);">üéÆ CONTROLS:</strong><br>
	            <div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.85rem; margin-top: 0.5rem;">
	                <div><strong>SPACEBAR</strong> or <strong>CLICK</strong> ‚Äì Jump</div>
	                <div><strong>Hold</strong> ‚Äì Higher Jump</div>
	            </div>
	        </div>
	    </div>
	</div>

	<!-- Space Invaders Game Modal -->
	<div class="modal" id="invadersModal" role="dialog" aria-labelledby="invadersModalTitle" aria-modal="true">
	    <div class="modal-content">
	        <div class="modal-header">
	            <h2 class="modal-title" id="invadersModalTitle"><span aria-hidden="true">üëæ</span> SPACE INVADERS</h2>
	            <button class="close-btn" onclick="closeGame('invaders')" aria-label="Close game">√ó</button>
	        </div>

	        <div class="game-stats" role="status" aria-live="polite">
	            <div class="stat">
	                <div class="stat-value" id="invadersScore" aria-label="Current score">0</div>
	                <div class="stat-label">Score</div>
	            </div>
	            <div class="stat">
	                <div class="stat-value" id="invadersLives" aria-label="Lives remaining">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
	                <div class="stat-label">Lives</div>
	            </div>
	            <div class="stat">
	                <div class="stat-value" id="invadersWave" aria-label="Current wave">1</div>
	                <div class="stat-label">Wave</div>
	            </div>
	        </div>

	        <div class="invaders-game-area" id="invadersGameArea" role="application" aria-label="Game area">
	            <div class="invaders-player" id="invadersPlayer" aria-label="Player ship">üöÄ</div>
	        </div>

	        <div style="text-align: center;">
	            <button class="arcade-btn" onclick="startInvadersGame()" id="invadersStartBtn">
	                <span aria-hidden="true">üöÄ</span> START DEFENSE
	            </button>
	        </div>

	        <div style="margin-top: 2rem; padding: 1rem; background: rgba(0,0,0,0.3); border-radius: 10px; font-size: 0.9rem; line-height: 1.6;">
	            <strong style="color: var(--clr-neon-cyan);">üéÆ CONTROLS:</strong><br>
	            <div style="display: flex; gap: 1rem; flex-wrap: wrap; font-size: 0.85rem; margin-top: 0.5rem;">
	                <div><strong>ARROWS</strong> or <strong>A/D</strong> ‚Äì Move</div>
	                <div><strong>SPACEBAR</strong> ‚Äì Shoot</div>
	                <div><strong>MOUSE</strong> ‚Äì Click to move & shoot</div>
	            </div>
	        </div>
	    </div>
	</div>

	<!-- Game Over Alert -->
	<div class="game-over-alert" id="gameOverAlert" role="alertdialog" aria-labelledby="gameOverTitle">
		<div style="font-size: 4rem;" aria-hidden="true">üèÜ</div>
		<h2 id="gameOverTitle">GAME OVER!</h2>
		<p style="opacity: 0.8; margin-bottom: 0.5rem;">YOUR FINAL SCORE</p>
		<div class="final-score-display" id="finalScore" aria-live="assertive">0</div>
		<button class="arcade-btn" onclick="closeGameOverAlert()" style="margin-top: 1rem;">
			<span aria-hidden="true">‚úì</span> CONTINUE
		</button>
	</div>

	<!-- Memory Victory Alert -->
	<div class="game-over-alert" id="memoryVictoryAlert" role="alertdialog" aria-labelledby="victoryTitle">
		<div style="font-size: 4rem;" aria-hidden="true">üéâ</div>
		<h2 id="victoryTitle">PERFECT MATCH!</h2>
		<p style="opacity: 0.8; margin-bottom: 0.5rem;">COMPLETED IN</p>
		<div class="final-score-display" id="finalMoves" aria-live="assertive">0</div>
		<p style="font-size: 1.2rem; margin-top: 0.5rem; opacity: 0.9;">MOVES</p>
		<button class="arcade-btn" onclick="closeMemoryVictory()" style="margin-top: 1rem;">
			<span aria-hidden="true">üîÑ</span> PLAY AGAIN
		</button>
	</div>

	<!-- Runner Game Over Alert -->
	<div class="game-over-alert" id="runnerGameOverAlert" role="alertdialog" aria-labelledby="runnerGameOverTitle">
	    <div style="font-size: 4rem;" aria-hidden="true">üí•</div>
	    <h2 id="runnerGameOverTitle">CRASH!</h2>
	    <p style="opacity: 0.8; margin-bottom: 0.5rem;">YOU RAN</p>
	    <div class="final-score-display" id="runnerFinalScore" aria-live="assertive">0</div>
	    <p style="font-size: 1.2rem; margin-top: 0.5rem; opacity: 0.9;">METERS</p>
	    <button class="arcade-btn" onclick="closeRunnerGameOver()" style="margin-top: 1rem;">
	        <span aria-hidden="true">üîÑ</span> TRY AGAIN
	    </button>
	</div>

	<!-- Invaders Game Over Alert -->
	<div class="game-over-alert" id="invadersGameOverAlert" role="alertdialog" aria-labelledby="invadersGameOverTitle">
	    <div style="font-size: 4rem;" aria-hidden="true">üíÄ</div>
	    <h2 id="invadersGameOverTitle">INVADED!</h2>
	    <p style="opacity: 0.8; margin-bottom: 0.5rem;">FINAL SCORE</p>
	    <div class="final-score-display" id="invadersFinalScore" aria-live="assertive">0</div>
	    <p style="font-size: 1rem; margin-top: 0.5rem; opacity: 0.9;">Waves Survived: <span id="invadersFinalWave">0</span></p>
	    <button class="arcade-btn" onclick="closeInvadersGameOver()" style="margin-top: 1rem;">
	        <span aria-hidden="true">üîÑ</span> DEFEND AGAIN
	    </button>
	</div>

	<!-- Login Required Alert -->
	<div class="game-over-alert" id="loginAlert" role="alertdialog" aria-labelledby="loginAlertTitle">
		<div style="font-size: 4rem;" aria-hidden="true">üîí</div>
		<h2 id="loginAlertTitle" style="font-size: 1.5rem;">AUTHENTICATION REQUIRED</h2>
		<p style="opacity: 0.85; margin: 1.5rem 0; font-size: 1rem; line-height: 1.5;">
			Sign in with your Google account to:<br>
			<strong style="color: var(--clr-neon-cyan);">‚úì</strong> Save your high scores<br>
			<strong style="color: var(--clr-neon-cyan);">‚úì</strong> Compete on global leaderboards<br>
			<strong style="color: var(--clr-neon-cyan);">‚úì</strong> Track your progress
		</p>
		<button class="arcade-btn" onclick="closeLoginAlert(); loginWithGoogle();" style="margin-top: 1rem;">
			<span aria-hidden="true">‚≠ê</span> SIGN IN WITH GOOGLE <span aria-hidden="true">‚≠ê</span>
		</button>
		<button class="arcade-btn" onclick="closeLoginAlert()" style="margin-top: 0.5rem; background: rgba(255,255,255,0.1); border-color: rgba(255,255,255,0.3);">
			<span aria-hidden="true">‚Üê</span> MAYBE LATER
		</button>
	</div>
</body>

	<script>
		// Initialize stars
		document.addEventListener('DOMContentLoaded', () => {
		    initAuth();
		    initializeStars();
		});

		function initializeStars() {
		    const starsContainer = document.getElementById('starsContainer');
		    const fragment = document.createDocumentFragment(); // ‚úÖ Mejor rendimiento
		    
		    for (let i = 0; i < 100; i++) {
		        const star = document.createElement('div');
		        star.className = 'star';
		        star.style.left = `${Math.random() * 100}%`;
		        star.style.top = `${Math.random() * 100}%`;
		        star.style.animationDelay = `${Math.random() * 3}s`;
		        fragment.appendChild(star);
		    }
		    
		    starsContainer.appendChild(fragment);
		}

		// ===== A√ëADE ESTO: INICIALIZACI√ìN DE FIREBASE =====

	    // Pega aqu√≠ tu objeto de configuraci√≥n que copiaste
		const firebaseConfig = {
			apiKey: "AIzaSyDipUw7d4av0JwfudVDdECNjZXdjy3OGyw",
			authDomain: "juego-arcade-scores.firebaseapp.com",
			projectId: "juego-arcade-scores",
			storageBucket: "juego-arcade-scores.firebasestorage.app",
			messagingSenderId: "33838418828",
			appId: "1:33838418828:web:5aa1579a7f645992c2a4a9",
			measurementId: "G-47JPGCPBM0"
		};

	    // Inicializa Firebase y Firestore
		firebase.initializeApp(firebaseConfig);
		const db = firebase.firestore();

	    // ===== FIN DE LA INICIALIZACI√ìN DE FIREBASE =====

// ===== USER MANAGEMENT & FIRESTORE LOGIC =====
// 1. Define la variable 'auth'
		const auth = firebase.auth();
		let currentUser = null; // Esto ahora ser√° un objeto de Firebase, no un string

		// 2. Nueva funci√≥n: Iniciar sesi√≥n con Google
		async function loginWithGoogle() {
		    try {
		        const loginBtn = document.querySelector('#loginView .arcade-btn');
		        loginBtn.disabled = true;
		        loginBtn.textContent = '‚è≥ SIGNING IN...';
		        
		        const provider = new firebase.auth.GoogleAuthProvider();
		        await auth.signInWithPopup(provider);
		        
		    } catch (error) {
		        console.error("Error al iniciar sesi√≥n con Google:", error);
		        
		        let errorMessage = "There was an error signing in.";
		        if (error.code === 'auth/popup-closed-by-user') {
		            errorMessage = "Sign-in cancelled. Please try again.";
		        } else if (error.code === 'auth/popup-blocked') {
		            errorMessage = "Pop-up blocked! Please allow pop-ups for this site.";
		        }
		        
		        alert(errorMessage);
		    }
		}

		async function logout() {
		    try {
		        const logoutBtn = document.querySelector('#userView .arcade-btn:last-child');
		        logoutBtn.disabled = true;
		        logoutBtn.textContent = '‚è≥ LOGGING OUT...';
		        
		        await auth.signOut();
		    
		    } catch (error) {
		        console.error("Error al cerrar sesi√≥n:", error);
		        alert("There was an error logging out. Please try again.");
		    }
		}

        // 4. Nueva funci√≥n: El "Observador"
        // Esta funci√≥n se ejecuta CADA VEZ que el estado de login cambia
		function initAuth() {
			auth.onAuthStateChanged(user => {
				if (user) {
                    // *** EL USUARIO EST√Å CONECTADO ***
					console.log("Usuario conectado:", user.displayName, user.uid);
                    currentUser = user; // Guardamos el objeto de usuario COMPLETO
                    
                    document.getElementById('loginView').style.display = 'none';
                    document.getElementById('userView').style.display = 'flex';
                    // Mostramos su nombre real de Google
                    document.getElementById('displayUsername').textContent = user.displayName;
                    
                    loadUserStats();
                    loadLeaderboards();

                } else {
                    // *** EL USUARIO EST√Å DESCONECTADO ***
                	console.log("User logged out.");
                	currentUser = null;

                	document.getElementById('loginView').style.display = 'block';
                	document.getElementById('userView').style.display = 'none';

                	closeGame('catch');
                	closeGame('memory');

                    // Limpiar S√ìLO las vistas previas PERSONALES
                	document.getElementById('catchBestPreview').textContent = '-';
                	document.getElementById('memoryBestPreview').textContent = '-';

                    // CARGAR los leaderboards globales
                	loadLeaderboards();
                }
            });
		}

        // 5. Llama al observador cuando la p√°gina cargue
		document.addEventListener('DOMContentLoaded', initAuth);

		function isStorageAvailable() {
			// Esta funci√≥n ahora comprueba si 'db' (nuestra base de datos) existe.
			return typeof db !== 'undefined' && db !== null;
		}

		async function loadUserStats() {
		    if (!currentUser || !currentUser.uid || !isStorageAvailable()) return;
		    
		    try {
		        const docId = currentUser.uid;
		        
		        // Catch
		        const catchDoc = await db.collection('user_best_catch').doc(docId).get();
		        if (catchDoc.exists) {
		            document.getElementById('catchBestPreview').textContent = catchDoc.data().score;
		        }

		        // Memory
		        const memoryDoc = await db.collection('user_best_memory').doc(docId).get();
		        if (memoryDoc.exists) {
		            document.getElementById('memoryBestPreview').textContent = memoryDoc.data().score;
		        }
		        
		        // ‚úÖ RUNNER
		        const runnerDoc = await db.collection('user_best_runner').doc(docId).get();
		        if (runnerDoc.exists) {
		            document.getElementById('runnerBestPreview').textContent = runnerDoc.data().score;
		        }
		        
		        // ‚úÖ INVADERS
		        const invadersDoc = await db.collection('user_best_invaders').doc(docId).get();
		        if (invadersDoc.exists) {
		            document.getElementById('invadersBestPreview').textContent = invadersDoc.data().score;
		        }
		    } catch (error) {
		        console.error('Error loading user stats:', error);
		    }
		}

		// Evitar m√∫ltiples guardados simult√°neos
		let saveScoreTimeout = null;


async function saveScore(game, score) {
    if (!currentUser || !currentUser.uid || !isStorageAvailable()) {
        console.log('User not logged in or DB not available. Score not saved.');
        return;
    }
    
    // Cancelar guardado pendiente
    if (saveScoreTimeout) {
        clearTimeout(saveScoreTimeout);
    }
    
    // Esperar un momento antes de guardar (debounce)
    return new Promise((resolve) => {
        saveScoreTimeout = setTimeout(async () => {
            const isCatchGame = game === 'catch';
            const isMemoryGame = game === 'memory';
            
            // ‚úÖ Determinar nombre de colecci√≥n
            let collectionName;
            if (game === 'catch') collectionName = 'user_best_catch';
            else if (game === 'memory') collectionName = 'user_best_memory';
            else if (game === 'runner') collectionName = 'user_best_runner';
            else if (game === 'invaders') collectionName = 'user_best_invaders';
            else {
                console.error('Unknown game:', game);
                resolve();
                return;
            }
            
            const docId = currentUser.uid;
            const docRef = db.collection(collectionName).doc(docId);
            
            try {
                const doc = await docRef.get();
                let shouldSave = false;
                
                if (!doc.exists) {
                    console.log(`No previous score found for ${game}. Saving first score.`);
                    shouldSave = true;
                } else {
                    const existingScore = doc.data().score;
                    console.log(`Previous score for ${game}:`, existingScore, '| New score:', score);
                    
                    // Para Memory, menor es mejor
                    if (isMemoryGame) {
                        shouldSave = score < existingScore;
                    } else {
                        // Para otros juegos, mayor es mejor
                        shouldSave = score > existingScore;
                    }
                }
                
                if (shouldSave) {
                    console.log(`‚úÖ Saving new best score for ${game}: ${score}`);
                    await docRef.set({
                        username: currentUser.displayName,
                        score: score,
                        timestamp: firebase.firestore.FieldValue.serverTimestamp()
                    });
                    
                    console.log(`‚úÖ Score saved successfully for ${game}`);
                    
                    // ‚úÖ Recargar stats y leaderboards
                    await loadUserStats();
                    await loadLeaderboards();
                    
                } else {
                    console.log(`‚ÑπÔ∏è Score ${score} is not better than existing ${doc.data().score}. Not saving.`);
                }
                resolve();
            } catch (error) {
                console.error('‚ùå Error saving score:', error);
                console.error('Error details:', error.code, error.message);
                resolve();
            }
        }, 500);
    });
}

		async function loadLeaderboards() {
			if (!isStorageAvailable()) {
				document.getElementById('catchLeaderboard').innerHTML = '<li class="no-scores">Database not available</li>';
				document.getElementById('memoryLeaderboard').innerHTML = '<li class="no-scores">Database not available</li>';
				return;
			}
			await loadCatchLeaderboard();
			await loadMemoryLeaderboard();
			await loadRunnerLeaderboard(); // ‚úÖ NUEVO
    		await loadInvadersLeaderboard();
		}

		async function loadCatchLeaderboard() {
			if (!isStorageAvailable()) return;
			
			const leaderboardEl = document.getElementById('catchLeaderboard');
			leaderboardEl.innerHTML = '<li class="no-scores">Loading...</li>';

			try {
                // Pedir a Firestore los 10 mejores, ordenados por 'score' descendente
				const snapshot = await db.collection('user_best_catch')
				.orderBy('score', 'desc')
				.limit(10)
				.get();

				if (snapshot.empty) {
					leaderboardEl.innerHTML = '<li class="no-scores">No scores yet. Be the first!</li>';
					document.getElementById('catchWorldPreview').textContent = '-';
					return;
				}

				const sortedScores = snapshot.docs.map(doc => doc.data());

                // Actualizar el "World Record"
				document.getElementById('catchWorldPreview').textContent = sortedScores[0].score;

				leaderboardEl.innerHTML = sortedScores.map((score, index) => {
					const rankClass = index === 0 ? 'top-1' : index === 1 ? 'top-2' : index === 2 ? 'top-3' : '';
					const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
					return `
						<li class="leaderboard-item ${rankClass}">
							<span class="leaderboard-rank">${medal}</span>
							<span class="leaderboard-name">${score.username}</span>
							<span class="leaderboard-score">${score.score}</span>
						</li>
					`;
				}).join('');
			} catch (error) {
				console.error('Error loading catch leaderboard:', error);
				leaderboardEl.innerHTML = '<li class="no-scores">Error loading scores</li>';
			}
		}

		async function loadMemoryLeaderboard() {
			if (!isStorageAvailable()) return;

			const leaderboardEl = document.getElementById('memoryLeaderboard');
			leaderboardEl.innerHTML = '<li class="no-scores">Loading...</li>';

			try {
                // Pedir a Firestore los 10 mejores, ordenados por 'score' ascendente (menos movimientos es mejor)
				const snapshot = await db.collection('user_best_memory')
				.orderBy('score', 'asc')
				.limit(10)
				.get();

				if (snapshot.empty) {
					leaderboardEl.innerHTML = '<li class="no-scores">No scores yet. Be the first!</li>';
					document.getElementById('memoryWorldPreview').textContent = '-';
					return;
				}

				const sortedScores = snapshot.docs.map(doc => doc.data());

                // Actualizar el "World Record"
				document.getElementById('memoryWorldPreview').textContent = sortedScores[0].score;

				leaderboardEl.innerHTML = sortedScores.map((score, index) => {
					const rankClass = index === 0 ? 'top-1' : index === 1 ? 'top-2' : index === 2 ? 'top-3' : '';
					const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
					return `
						<li class="leaderboard-item ${rankClass}">
							<span class="leaderboard-rank">${medal}</span>
							<span class="leaderboard-name">${score.username}</span>
							<span class="leaderboard-score">${score.score}</span>
						</li>
					`;
				}).join('');
			} catch (error)
			{
				console.error('Error loading memory leaderboard:', error);
				leaderboardEl.innerHTML = '<li class="no-scores">Error loading scores</li>';
			}
		}

		// ===== MODAL MANAGEMENT =====
		function openGame(game) {
		    if (!currentUser) {
		        document.getElementById('loginAlert').classList.add('active');
		        return;
		    }

		    if (game === 'catch') {
		        document.getElementById('catchModal').classList.add('active');
		    } else if (game === 'memory') {
		        document.getElementById('memoryModal').classList.add('active');
		        initMemoryGame();
		    } else if (game === 'runner') { // ‚úÖ NUEVO
		        document.getElementById('runnerModal').classList.add('active');
		    } else if (game === 'invaders') { // ‚úÖ NUEVO
		        document.getElementById('invadersModal').classList.add('active');
		    }
		}

		function closeGame(game) {
		    if (game === 'catch') {
		        stopCatchGame();
		        document.getElementById('catchModal').classList.remove('active');
		    } else if (game === 'memory') {
		        document.getElementById('memoryModal').classList.remove('active');
		    } else if (game === 'runner') { // ‚úÖ NUEVO
		        stopRunnerGame();
		        document.getElementById('runnerModal').classList.remove('active');
		    } else if (game === 'invaders') { // ‚úÖ NUEVO
		        stopInvadersGame();
		        document.getElementById('invadersModal').classList.remove('active');
		    }
		}

		// Funci√≥n para cerrar la alerta de login
		function closeLoginAlert() {
			document.getElementById('loginAlert').classList.remove('active');
		}

		// Funci√≥n para cerrar la victoria de Memory
		function closeMemoryVictory() {
			document.getElementById('memoryVictoryAlert').classList.remove('active');
			initMemoryGame(); // Reinicia autom√°ticamente
		}

		// ===== CATCH GAME =====
		let catchGameActive = false;
		let catchScore = 0;
		let catchTime = 30;
		let catchMultiplier = 1;
		let catchInterval;
		let catchTimer;
		let itemCheckIntervals = [];
		let hasShield = false;
		let catcherSpeed = 1;
		let targetCatcherX = 0;
		let catcherAnimFrame;
		let catcherEl; // Para guardar el elemento
		let gameAreaRect; // Para guardar las dimensiones

		function startCatchGame() {
			if (catchGameActive || !currentUser) return;
			
			document.getElementById('gameOverAlert').classList.remove('active');
			
			catchGameActive = true;
			catchScore = 0;
			catchTime = 30;
			catchMultiplier = 1;
			hasShield = false;
			catcherSpeed = 1;
			
			document.getElementById('catchScore').textContent = catchScore;
			document.getElementById('catchTime').textContent = catchTime;
			document.getElementById('catchMultiplier').textContent = 'x' + catchMultiplier;
			document.getElementById('catcher').style.filter = 'drop-shadow(0 0 10px rgba(255, 190, 11, 0.8))';
			
			document.querySelectorAll('.falling-item').forEach(item => item.remove());
			
			document.getElementById('catchStartBtn').disabled = true;
			
			catchInterval = setInterval(createFallingItem, 700);
			catchTimer = setInterval(() => {
				catchTime--;
				document.getElementById('catchTime').textContent = catchTime;
				if (catchTime <= 0) {
					stopCatchGame();
					showGameOverAlert();
				}
			}, 1000);
		}

		function stopCatchGame() {
			catchGameActive = false;
			clearInterval(catchInterval);
			clearInterval(catchTimer);
			
			itemCheckIntervals.forEach(interval => clearInterval(interval));
			itemCheckIntervals = [];
			
			document.querySelectorAll('.falling-item').forEach(item => item.remove());
			
			document.getElementById('catchStartBtn').disabled = false;
		}

		function createFallingItem() {
		    if (!catchGameActive) return;
		    
		    const item = document.createElement('div');
		    item.className = 'falling-item';
			
			const rand = Math.random();
			let itemType;
			
			if (rand < 0.15) {
				itemType = 'bomb';
				item.textContent = 'üí£';
			} else if (rand < 0.25) {
				// Power-ups
				const powerups = ['‚ö°', 'üåü', '‚è∞', 'üõ°Ô∏è'];
				const powerup = powerups[Math.floor(Math.random() * powerups.length)];
				item.textContent = powerup;
				itemType = 'powerup';
				item.dataset.powerup = powerup;
				item.classList.add('powerup');
			} else {
				itemType = 'star';
				item.textContent = '‚≠ê';
			}
			
			item.dataset.type = itemType;
			
			const gameWidth = document.getElementById('catchGameArea').offsetWidth;
			item.style.left = Math.random() * (gameWidth - 60) + 'px';
			item.style.top = '-80px'; // M√°s arriba para dar m√°s espacio

			const baseDuration = Math.random() * 1.5 + 4; // Duraci√≥n m√°s larga y menos aleatoria
			const duration = baseDuration / catcherSpeed;
			item.style.animation = `fall ${duration}s linear`;
			
			document.getElementById('catchGameArea').appendChild(item);
			
			let hasCollided = false;
    		let animationFrameId;
			
			const checkCollision = () => {
		        if (!catchGameActive || !item.parentElement || hasCollided) {
		            cancelAnimationFrame(animationFrameId);
		            return;
		        }
		        
		        const itemRect = item.getBoundingClientRect();
		        const catcherRect = document.getElementById('catcher').getBoundingClientRect();
		        
		        // Verificar si est√°n colisionando
		        const isColliding = (
		            itemRect.bottom >= catcherRect.top &&
		            itemRect.top <= catcherRect.bottom &&
		            itemRect.right >= catcherRect.left &&
		            itemRect.left <= catcherRect.right
		        );
		        
		        if (isColliding) {
		            hasCollided = true;
		            handleItemCatch(item);
		            cancelAnimationFrame(animationFrameId);
		            return;
		        }
		        
		        // Continuar verificando en el siguiente frame
		        animationFrameId = requestAnimationFrame(checkCollision);
		    };
		    
		    animationFrameId = requestAnimationFrame(checkCollision);
		    
		    // Limpiar despu√©s de que el item caiga
		    setTimeout(() => {
		        if (item.parentElement) item.remove();
		        cancelAnimationFrame(animationFrameId);
		    }, duration * 1000 + 1000);
		}

		// Funci√≥n separada para manejar lo que pasa cuando atrapas algo
		function handleItemCatch(item) {
		    if (item.dataset.type === 'star') {
		        catchScore += 10 * catchMultiplier;
		        document.getElementById('catchScore').textContent = catchScore;
		        item.style.transition = 'transform 0.2s ease-out, opacity 0.2s ease-out';
		        item.style.transform = 'scale(2)';
		        item.style.opacity = '0';
		    } else if (item.dataset.type === 'powerup') {
		        applyPowerup(item.dataset.powerup);
		        item.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
		        item.style.transform = 'scale(2) rotate(360deg)';
		        item.style.opacity = '0';
		    } else if (item.dataset.type === 'bomb') {
		        if (!hasShield) {
		            catchScore = Math.max(0, catchScore - 30);
		            document.getElementById('catchScore').textContent = catchScore;
		            
		            const catcher = document.getElementById('catcher');
		            catcher.style.animation = 'shake 0.3s ease-in-out';
		            setTimeout(() => catcher.style.animation = '', 300);
		        } else {
		            hasShield = false;
		            document.getElementById('catcher').style.filter = 'drop-shadow(0 0 10px rgba(255, 190, 11, 0.8))';
		        }
		    }
		    
		    setTimeout(() => {
		        if (item.parentElement) item.remove();
		    }, 300);
		}

		function applyPowerup(powerup) {
			switch(powerup) {
			case '‚ö°':
				catcherSpeed = 1.5;
				setTimeout(() => catcherSpeed = 1, 5000);
				break;
			case 'üåü':
				catchMultiplier = 2;
				document.getElementById('catchMultiplier').textContent = 'x' + catchMultiplier;
				setTimeout(() => {
					catchMultiplier = 1;
					document.getElementById('catchMultiplier').textContent = 'x' + catchMultiplier;
				}, 5000);
				break;
			case '‚è∞':
				catchTime += 10;
				document.getElementById('catchTime').textContent = catchTime;
				break;
			case 'üõ°Ô∏è':
				hasShield = true;
				document.getElementById('catcher').style.filter = 'drop-shadow(0 0 20px rgba(0, 255, 249, 1))';
				break;
			}
		}

		async function showGameOverAlert() {
			document.getElementById('finalScore').textContent = catchScore;
			document.getElementById('gameOverAlert').classList.add('active');
			await saveScore('catch', catchScore);
		}

		function closeGameOverAlert() {
			document.getElementById('gameOverAlert').classList.remove('active');
		}

		let catcherX = 0;
		document.getElementById('catchGameArea').addEventListener('mousemove', (e) => {
			if (!catchGameActive) return;
			const game = document.getElementById('catchGameArea');
			const catcher = document.getElementById('catcher');
			const rect = game.getBoundingClientRect();
			catcherX = e.clientX - rect.left - 40;
			catcherX = Math.max(0, Math.min(catcherX, game.offsetWidth - 80));
			catcher.style.left = catcherX + 'px';
		});

		// Touch support for mobile
		document.getElementById('catchGameArea').addEventListener('touchmove', (e) => {
			if (!catchGameActive) return;
			e.preventDefault();
			const game = document.getElementById('catchGameArea');
			const catcher = document.getElementById('catcher');
			const rect = game.getBoundingClientRect();
			const touch = e.touches[0];
			catcherX = touch.clientX - rect.left - 40;
			catcherX = Math.max(0, Math.min(catcherX, game.offsetWidth - 80));
			catcher.style.left = catcherX + 'px';
		});

		// ===== MEMORY GAME =====
		const emojis = ['üéÆ', 'üïπÔ∏è', 'üëæ', 'üéØ', 'üé≤', 'üÉè', 'üé∞', 'üèÜ'];
		let memoryCards = [];
		let flippedCards = [];
		let moves = 0;
		let pairs = 0;
		let memoryGameActive = false;
		let memoryStartTime = 0;
		let memoryTimer;

		function initMemoryGame() {
			if (!currentUser) return;
			
			const gameContainer = document.getElementById('memoryGrid');
			gameContainer.innerHTML = '';
			memoryCards = [...emojis, ...emojis].sort(() => Math.random() - 0.5);
			flippedCards = [];
			moves = 0;
			pairs = 0;
			memoryGameActive = true;
			memoryStartTime = Date.now();
			
			document.getElementById('memoryMoves').textContent = moves;
			document.getElementById('memoryPairs').textContent = `${pairs}/8`;

			memoryCards.forEach((emoji, index) => {
				const card = document.createElement('div');
				card.className = 'memory-card';
				card.dataset.emoji = emoji;
				card.dataset.index = index;
				card.addEventListener('click', flipCard);
				gameContainer.appendChild(card);
			});
		}

		let isProcessingFlip = false;

		function flipCard() {
		    if (!memoryGameActive || isProcessingFlip) return;
		    if (flippedCards.length === 2 || this.classList.contains('flipped') || this.classList.contains('matched')) {
		        return;
		    }
		    
		    this.textContent = this.dataset.emoji;
		    this.classList.add('flipped');
		    flippedCards.push(this);
		    
		    if (flippedCards.length === 2) {
		        isProcessingFlip = true; // ‚úÖ Bloquear clicks mientras se procesan las cartas
		        moves++;
		        document.getElementById('memoryMoves').textContent = moves;
		        
		        setTimeout(async () => {
		            if (flippedCards[0].dataset.emoji === flippedCards[1].dataset.emoji) {
		                flippedCards[0].classList.add('matched');
		                flippedCards[1].classList.add('matched');
		                pairs++;
		                document.getElementById('memoryPairs').textContent = `${pairs}/8`;
		                
		                if (pairs === 8) {
		                    memoryGameActive = false;
		                    setTimeout(async () => {
		                        document.getElementById('finalMoves').textContent = moves;
		                        document.getElementById('memoryVictoryAlert').classList.add('active');
		                        await saveScore('memory', moves);
		                    }, 300);
		                }
		            } else {
		                flippedCards[0].textContent = '';
		                flippedCards[1].textContent = '';
		                flippedCards[0].classList.remove('flipped');
		                flippedCards[1].classList.remove('flipped');
		            }
		            flippedCards = [];
		            isProcessingFlip = false; // ‚úÖ Desbloquear clicks
		        }, 800);
		    }
		}

		// Add shake and fall animations
		const style = document.createElement('style');
		style.textContent = `
			@keyframes shake {
				0%, 100% { transform: translateX(0); }
				25% { transform: translateX(-10px); }
				75% { transform: translateX(10px); }
			}
			@keyframes fall {
				to { transform: translateY(550px); }
			}
		`;
		document.head.appendChild(style);

		// ===== NEON RUNNER GAME =====
		let runnerGameActive = false;
		let runnerScore = 0;
		let runnerSpeed = 1;
		let runnerObstacles = [];
		let runnerInterval;
		let runnerScoreInterval;
		let isJumping = false;

		function startRunnerGame() {
		    if (runnerGameActive || !currentUser) return;
		    
		    document.getElementById('runnerGameOverAlert').classList.remove('active');
		    
		    runnerGameActive = true;
		    runnerScore = 0;
		    runnerSpeed = 1;
		    runnerObstacles = [];
		    isJumping = false;
		    
		    document.getElementById('runnerScore').textContent = runnerScore;
		    document.getElementById('runnerSpeed').textContent = runnerSpeed.toFixed(1) + 'x';
		    document.getElementById('runnerStartBtn').disabled = true;
		    
		    // Limpiar obst√°culos anteriores
		    document.querySelectorAll('.runner-obstacle').forEach(obs => obs.remove());
		    
		    // Crear obst√°culos
		    runnerInterval = setInterval(() => {
		        if (!runnerGameActive) return;
		        createObstacle();
		    }, 2000 / runnerSpeed);
		    
		    // Incrementar score
		    runnerScoreInterval = setInterval(() => {
		        if (!runnerGameActive) return;
		        runnerScore += Math.floor(runnerSpeed * 10);
		        document.getElementById('runnerScore').textContent = runnerScore;
		        
		        // Aumentar velocidad gradualmente
		        if (runnerScore % 100 === 0) {
		            runnerSpeed += 0.1;
		            document.getElementById('runnerSpeed').textContent = runnerSpeed.toFixed(1) + 'x';
		            
		            // Actualizar velocidad de generaci√≥n de obst√°culos
		            clearInterval(runnerInterval);
		            runnerInterval = setInterval(() => {
		                if (!runnerGameActive) return;
		                createObstacle();
		            }, 2000 / runnerSpeed);
		        }
		    }, 100);
		}

		function stopRunnerGame() {
		    runnerGameActive = false;
		    clearInterval(runnerInterval);
		    clearInterval(runnerScoreInterval);
		    
		    document.querySelectorAll('.runner-obstacle').forEach(obs => obs.remove());
		    document.getElementById('runnerStartBtn').disabled = false;
		}

		function createObstacle() {
		    if (!runnerGameActive) return;
		    
		    const obstacle = document.createElement('div');
		    obstacle.className = 'runner-obstacle';
		    
		    const obstacles = ['üåµ', 'ü™®', '‚ö°', 'üî•'];
		    obstacle.textContent = obstacles[Math.floor(Math.random() * obstacles.length)];
		    
		    const gameArea = document.getElementById('runnerGameArea');
		    obstacle.style.insetInlineStart = gameArea.offsetWidth + 'px';
		    
		    const duration = (3 / runnerSpeed);
		    obstacle.style.animationDuration = duration + 's';
		    
		    gameArea.appendChild(obstacle);
		    runnerObstacles.push(obstacle);
		    
		    // Verificar colisiones
		    let collisionCheckInterval = setInterval(() => {
		        if (!runnerGameActive || !obstacle.parentElement) {
		            clearInterval(collisionCheckInterval);
		            return;
		        }
		        
		        const playerRect = document.getElementById('runnerPlayer').getBoundingClientRect();
		        const obstacleRect = obstacle.getBoundingClientRect();
		        
		        const isColliding = (
		            playerRect.right > obstacleRect.left &&
		            playerRect.left < obstacleRect.right &&
		            playerRect.bottom > obstacleRect.top &&
		            playerRect.top < obstacleRect.bottom
		        );
		        
		        if (isColliding && !isJumping) {
		            clearInterval(collisionCheckInterval);
		            stopRunnerGame();
		            showRunnerGameOver();
		        }
		    }, 10);
		    
		    // Remover obst√°culo despu√©s de que salga de pantalla
		    setTimeout(() => {
		        if (obstacle.parentElement) {
		            obstacle.remove();
		            runnerObstacles = runnerObstacles.filter(obs => obs !== obstacle);
		        }
		        clearInterval(collisionCheckInterval);
		    }, duration * 1000 + 500);
		}

		function jump() {
		    if (!runnerGameActive || isJumping) return;
		    
		    isJumping = true;
		    const player = document.getElementById('runnerPlayer');
		    player.classList.add('jumping');
		    
		    setTimeout(() => {
		        player.classList.remove('jumping');
		        isJumping = false;
		    }, 500);
		}

		// Controles de salto
		document.addEventListener('keydown', (e) => {
		    if (e.code === 'Space' && runnerGameActive) {
		        e.preventDefault();
		        jump();
		    }
		});

		document.getElementById('runnerGameArea').addEventListener('click', () => {
		    if (runnerGameActive) jump();
		});

		document.getElementById('runnerGameArea').addEventListener('touchstart', (e) => {
		    if (runnerGameActive) {
		        e.preventDefault();
		        jump();
		    }
		});

		async function showRunnerGameOver() {
		    document.getElementById('runnerFinalScore').textContent = runnerScore;
		    document.getElementById('runnerGameOverAlert').classList.add('active');
		    await saveScore('runner', runnerScore);
		}

		function closeRunnerGameOver() {
		    document.getElementById('runnerGameOverAlert').classList.remove('active');
		}

		// Cargar stats de Runner
		async function loadRunnerStats() {
		    if (!currentUser || !currentUser.uid || !isStorageAvailable()) return;
		    
		    try {
		        const docId = currentUser.uid;
		        const runnerDoc = await db.collection('user_best_runner').doc(docId).get();
		        if (runnerDoc.exists) {
		            document.getElementById('runnerBestPreview').textContent = runnerDoc.data().score;
		        }
		    } catch (error) {
		        console.error('Error loading runner stats:', error);
		    }
		}

async function loadRunnerLeaderboard() {
    if (!isStorageAvailable()) return;
    
    const leaderboardEl = document.getElementById('runnerLeaderboard');
    if (!leaderboardEl) return; // Si no existe el elemento, salir
    
    leaderboardEl.innerHTML = '<li class="no-scores">Loading...</li>';

    try {
        const snapshot = await db.collection('user_best_runner')
            .orderBy('score', 'desc')
            .limit(10)
            .get();

        if (snapshot.empty) {
            leaderboardEl.innerHTML = '<li class="no-scores">No scores yet. Be the first!</li>';
            document.getElementById('runnerWorldPreview').textContent = '-';
            return;
        }

        const sortedScores = snapshot.docs.map(doc => doc.data());
        document.getElementById('runnerWorldPreview').textContent = sortedScores[0].score;

        leaderboardEl.innerHTML = sortedScores.map((score, index) => {
            const rankClass = index === 0 ? 'top-1' : index === 1 ? 'top-2' : index === 2 ? 'top-3' : '';
            const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
            return `
                <li class="leaderboard-item ${rankClass}">
                    <span class="leaderboard-rank">${medal}</span>
                    <span class="leaderboard-name">${score.username}</span>
                    <span class="leaderboard-score">${score.score}</span>
                </li>
            `;
        }).join('');
    } catch (error) {
        console.error('Error loading runner leaderboard:', error);
        leaderboardEl.innerHTML = '<li class="no-scores">Error loading scores</li>';
    }
}

		// ===== SPACE INVADERS GAME =====
let invadersGameActive = false;
let invadersScore = 0;
let invadersLives = 3;
let invadersWave = 1;
let invadersList = [];
let bulletsList = [];
let enemyBulletsList = [];
let invadersPlayerX = 0;
let invadersGameLoop;
let invadersShootInterval;
let lastShotTime = 0;
const shootCooldown = 300;

function startInvadersGame() {
    if (invadersGameActive || !currentUser) return;
    
    document.getElementById('invadersGameOverAlert').classList.remove('active');
    
    invadersGameActive = true;
    invadersScore = 0;
    invadersLives = 3;
    invadersWave = 1;
    invadersList = [];
    bulletsList = [];
    enemyBulletsList = [];
    
    document.getElementById('invadersScore').textContent = invadersScore;
    document.getElementById('invadersLives').textContent = '‚ù§Ô∏è'.repeat(invadersLives);
    document.getElementById('invadersWave').textContent = invadersWave;
    document.getElementById('invadersStartBtn').disabled = true;
    
    // Limpiar elementos anteriores
    document.querySelectorAll('.invader, .bullet, .enemy-bullet, .explosion').forEach(el => el.remove());
    
    // Posicionar jugador
    const gameArea = document.getElementById('invadersGameArea');
    const player = document.getElementById('invadersPlayer');
    invadersPlayerX = (gameArea.offsetWidth - player.offsetWidth) / 2;
    player.style.left = invadersPlayerX + 'px';
    
    createInvaderWave();
    
    invadersGameLoop = setInterval(updateInvadersGame, 1000 / 60);
    invadersShootInterval = setInterval(enemyShoot, 1500);
}

function stopInvadersGame() {
    invadersGameActive = false;
    clearInterval(invadersGameLoop);
    clearInterval(invadersShootInterval);
    
    document.querySelectorAll('.invader, .bullet, .enemy-bullet, .explosion').forEach(el => el.remove());
    document.getElementById('invadersStartBtn').disabled = false;
}

function createInvaderWave() {
    const gameArea = document.getElementById('invadersGameArea');
    const rows = 3 + Math.floor(invadersWave / 3);
    const cols = 5 + Math.floor(invadersWave / 2);
    const spacing = Math.min(60, gameArea.offsetWidth / (cols + 1));
    
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const invader = document.createElement('div');
            invader.className = 'invader';
            invader.textContent = ['üëæ', 'üëΩ', 'üõ∏'][row % 3];
            
            const x = col * spacing + 30;
            const y = row * 50 + 30;
            
            invader.style.left = x + 'px';
            invader.style.top = y + 'px';
            invader.dataset.x = x;
            invader.dataset.y = y;
            invader.dataset.direction = 1;
            
            gameArea.appendChild(invader);
            invadersList.push(invader);
        }
    }
}

function updateInvadersGame() {
    if (!invadersGameActive) return;
    
    // Mover invasores
    let shouldMoveDown = false;
    const gameArea = document.getElementById('invadersGameArea');
    const maxWidth = gameArea.offsetWidth;
    
    invadersList.forEach(invader => {
        let x = parseFloat(invader.dataset.x);
        const y = parseFloat(invader.dataset.y);
        const direction = parseFloat(invader.dataset.direction);
        
        x += direction * 0.5 * (1 + invadersWave * 0.1);
        
        if (x <= 0 || x >= maxWidth - 50) {
            shouldMoveDown = true;
        }
        
        invader.dataset.x = x;
        invader.style.left = x + 'px';
    });
    
    if (shouldMoveDown) {
        invadersList.forEach(invader => {let y = parseFloat(invader.dataset.y);
            y += 20;
            invader.dataset.y = y;
            invader.style.top = y + 'px';
            invader.dataset.direction *= -1;
            
            // Game over si llegan abajo
            if (y > gameArea.offsetHeight - 100) {
                loseLife();
            }
        });
    }
    
    // Mover balas del jugador
    bulletsList.forEach((bullet, index) => {
        if (!bullet.parentElement) {
            bulletsList.splice(index, 1);
            return;
        }
        
        let y = parseFloat(bullet.style.top);
        y -= 8;
        bullet.style.top = y + 'px';
        
        // Remover si sale de pantalla
        if (y < 0) {
            bullet.remove();
            bulletsList.splice(index, 1);
            return;
        }
        
        // Verificar colisi√≥n con invasores
        const bulletRect = bullet.getBoundingClientRect();
        invadersList.forEach((invader, invIndex) => {
            if (!invader.parentElement) return;
            
            const invaderRect = invader.getBoundingClientRect();
            if (checkCollision(bulletRect, invaderRect)) {
                createExplosion(invaderRect.left, invaderRect.top);
                invader.remove();
                invadersList.splice(invIndex, 1);
                bullet.remove();
                bulletsList.splice(index, 1);
                
                invadersScore += 10 * invadersWave;
                document.getElementById('invadersScore').textContent = invadersScore;
                
                // Nueva oleada si eliminamos todos
                if (invadersList.length === 0) {
                    invadersWave++;
                    document.getElementById('invadersWave').textContent = invadersWave;
                    setTimeout(() => createInvaderWave(), 1000);
                }
            }
        });
    });
    
    // Mover balas enemigas
    enemyBulletsList.forEach((bullet, index) => {
        if (!bullet.parentElement) {
            enemyBulletsList.splice(index, 1);
            return;
        }
        
        let y = parseFloat(bullet.style.top);
        y += 4;
        bullet.style.top = y + 'px';
        
        // Remover si sale de pantalla
        if (y > gameArea.offsetHeight) {
            bullet.remove();
            enemyBulletsList.splice(index, 1);
            return;
        }
        
        // Verificar colisi√≥n con jugador
        const bulletRect = bullet.getBoundingClientRect();
        const playerRect = document.getElementById('invadersPlayer').getBoundingClientRect();
        
        if (checkCollision(bulletRect, playerRect)) {
            bullet.remove();
            enemyBulletsList.splice(index, 1);
            loseLife();
        }
    });
}

function checkCollision(rect1, rect2) {
    return (
        rect1.left < rect2.right &&
        rect1.right > rect2.left &&
        rect1.top < rect2.bottom &&
        rect1.bottom > rect2.top
    );
}

function shootBullet() {
    if (!invadersGameActive) return;
    
    const now = Date.now();
    if (now - lastShotTime < shootCooldown) return;
    lastShotTime = now;
    
    const player = document.getElementById('invadersPlayer');
    const bullet = document.createElement('div');
    bullet.className = 'bullet';
    
    const playerRect = player.getBoundingClientRect();
    const gameAreaRect = document.getElementById('invadersGameArea').getBoundingClientRect();
    
    bullet.style.left = (playerRect.left - gameAreaRect.left + playerRect.width / 2 - 2) + 'px';
    bullet.style.top = (playerRect.top - gameAreaRect.top) + 'px';
    
    document.getElementById('invadersGameArea').appendChild(bullet);
    bulletsList.push(bullet);
}

function enemyShoot() {
    if (!invadersGameActive || invadersList.length === 0) return;
    
    // Seleccionar un invasor aleatorio
    const shooter = invadersList[Math.floor(Math.random() * invadersList.length)];
    if (!shooter || !shooter.parentElement) return;
    
    const bullet = document.createElement('div');
    bullet.className = 'bullet enemy-bullet';
    
    const shooterRect = shooter.getBoundingClientRect();
    const gameAreaRect = document.getElementById('invadersGameArea').getBoundingClientRect();
    
    bullet.style.left = (shooterRect.left - gameAreaRect.left + shooterRect.width / 2 - 2) + 'px';
    bullet.style.top = (shooterRect.bottom - gameAreaRect.top) + 'px';
    
    document.getElementById('invadersGameArea').appendChild(bullet);
    enemyBulletsList.push(bullet);
}

function createExplosion(x, y) {
    const explosion = document.createElement('div');
    explosion.className = 'explosion';
    explosion.textContent = 'üí•';
    explosion.style.left = x + 'px';
    explosion.style.top = y + 'px';
    
    document.getElementById('invadersGameArea').appendChild(explosion);
    
    setTimeout(() => explosion.remove(), 500);
}

function loseLife() {
    invadersLives--;
    document.getElementById('invadersLives').textContent = '‚ù§Ô∏è'.repeat(Math.max(0, invadersLives));
    
    if (invadersLives <= 0) {
        stopInvadersGame();
        showInvadersGameOver();
    } else {
        // Flash del jugador
        const player = document.getElementById('invadersPlayer');
        player.style.animation = 'shake 0.3s ease-in-out';
        setTimeout(() => player.style.animation = '', 300);
    }
}

async function showInvadersGameOver() {
    document.getElementById('invadersFinalScore').textContent = invadersScore;
    document.getElementById('invadersFinalWave').textContent = invadersWave;
    document.getElementById('invadersGameOverAlert').classList.add('active');
    await saveScore('invaders', invadersScore);
}

function closeInvadersGameOver() {
    document.getElementById('invadersGameOverAlert').classList.remove('active');
}

// Controles de movimiento
let keysPressed = {};

document.addEventListener('keydown', (e) => {
    if (!invadersGameActive) return;
    keysPressed[e.key] = true;
    
    if (e.code === 'Space') {
        e.preventDefault();
        shootBullet();
    }
});

document.addEventListener('keyup', (e) => {
    keysPressed[e.key] = false;
});

// Actualizar posici√≥n del jugador basado en teclas
setInterval(() => {
    if (!invadersGameActive) return;
    
    const gameArea = document.getElementById('invadersGameArea');
    const player = document.getElementById('invadersPlayer');
    const speed = 5;
    
    if (keysPressed['ArrowLeft'] || keysPressed['a'] || keysPressed['A']) {
        invadersPlayerX = Math.max(0, invadersPlayerX - speed);
    }
    if (keysPressed['ArrowRight'] || keysPressed['d'] || keysPressed['D']) {
        invadersPlayerX = Math.min(gameArea.offsetWidth - player.offsetWidth, invadersPlayerX + speed);
    }
    
    player.style.left = invadersPlayerX + 'px';
}, 16);

// Control con mouse/touch
document.getElementById('invadersGameArea').addEventListener('mousemove', (e) => {
    if (!invadersGameActive) return;
    
    const gameArea = document.getElementById('invadersGameArea');
    const player = document.getElementById('invadersPlayer');
    const rect = gameArea.getBoundingClientRect();
    
    invadersPlayerX = e.clientX - rect.left - player.offsetWidth / 2;
    invadersPlayerX = Math.max(0, Math.min(invadersPlayerX, gameArea.offsetWidth - player.offsetWidth));
    player.style.left = invadersPlayerX + 'px';
});

document.getElementById('invadersGameArea').addEventListener('click', (e) => {
    if (invadersGameActive) {
        e.preventDefault();
        shootBullet();
    }
});

document.getElementById('invadersGameArea').addEventListener('touchmove', (e) => {
    if (!invadersGameActive) return;
    e.preventDefault();
    
    const gameArea = document.getElementById('invadersGameArea');
    const player = document.getElementById('invadersPlayer');
    const rect = gameArea.getBoundingClientRect();
    const touch = e.touches[0];
    
    invadersPlayerX = touch.clientX - rect.left - player.offsetWidth / 2;
    invadersPlayerX = Math.max(0, Math.min(invadersPlayerX, gameArea.offsetWidth - player.offsetWidth));
    player.style.left = invadersPlayerX + 'px';
});

document.getElementById('invadersGameArea').addEventListener('touchstart', (e) => {
    if (invadersGameActive) {
        e.preventDefault();
        shootBullet();
    }
});

// Cargar stats de Invaders
async function loadInvadersStats() {
    if (!currentUser || !currentUser.uid || !isStorageAvailable()) return;
    
    try {
        const docId = currentUser.uid;
        const invadersDoc = await db.collection('user_best_invaders').doc(docId).get();
        if (invadersDoc.exists) {
            document.getElementById('invadersBestPreview').textContent = invadersDoc.data().score;
        }
    } catch (error) {
        console.error('Error loading invaders stats:', error);
    }
}

async function loadInvadersLeaderboard() {
    if (!isStorageAvailable()) return;

    const leaderboardEl = document.getElementById('invadersLeaderboard');
    if (!leaderboardEl) return;
    
    leaderboardEl.innerHTML = '<li class="no-scores">Loading...</li>';

    try {
        const snapshot = await db.collection('user_best_invaders')
            .orderBy('score', 'desc')
            .limit(10)
            .get();

        if (snapshot.empty) {
            leaderboardEl.innerHTML = '<li class="no-scores">No scores yet. Be the first!</li>';
            document.getElementById('invadersWorldPreview').textContent = '-';
            return;
        }

        const sortedScores = snapshot.docs.map(doc => doc.data());
        document.getElementById('invadersWorldPreview').textContent = sortedScores[0].score;

        leaderboardEl.innerHTML = sortedScores.map((score, index) => {
            const rankClass = index === 0 ? 'top-1' : index === 1 ? 'top-2' : index === 2 ? 'top-3' : '';
            const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
            return `
                <li class="leaderboard-item ${rankClass}">
                    <span class="leaderboard-rank">${medal}</span>
                    <span class="leaderboard-name">${score.username}</span>
                    <span class="leaderboard-score">${score.score}</span>
                </li>
            `;
        }).join('');
    } catch (error) {
        console.error('Error loading invaders leaderboard:', error);
        leaderboardEl.innerHTML = '<li class="no-scores">Error loading scores</li>';
    }
}

		// Load leaderboards on page load
		window.addEventListener('load', async () => {
			// Esperar a que storage est√© disponible
			let attempts = 0;
			const checkStorage = setInterval(async () => {
				attempts++;
				if (isStorageAvailable()) {
					clearInterval(checkStorage);
					await loadLeaderboards();
				} else if (attempts > 20) {
					clearInterval(checkStorage);
					console.log('Storage not available after 2 seconds');
					document.getElementById('catchLeaderboard').innerHTML = '<li class="no-scores">Storage not available</li>';
					document.getElementById('memoryLeaderboard').innerHTML = '<li class="no-scores">Storage not available</li>';
				}
			}, 100);
		});
	</script>
</body>
</html>
